<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SWPatterns.com</title><link>https://swpatterns.com/pattern_types/ddd/</link><description>Recent content on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 17:30:00 +0000</lastBuildDate><atom:link href="https://swpatterns.com/pattern_types/ddd/index.xml" rel="self" type="application/rss+xml"/><item><title>Partnership</title><link>https://swpatterns.com/pattern/partnership/</link><pubDate>Thu, 29 Feb 2024 17:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/partnership/</guid><description>
&lt;p&gt;The Partnership pattern defines a relationship between two or more independent entities (Partners) who collaborate to achieve a common goal through a shared state. Each Partner maintains its own autonomy but relies on the SharedState for synchronization and data exchange, effectively creating a bounded collaboration. This differs from simple composition or aggregation where one entity inherently “owns” or “has” the other.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Partnership pattern is useful in scenarios requiring distributed decision-making, resource management, or complex workflows where individual components need to react to changes originating from others, managed through a centralized, but openly accessible state. Common usages include collaborative editing applications, distributed task processing, and systems managing shared resources such as inventory or funds. It is crucial when maintaining loose coupling while ensuring coordinated behavior.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Git Branching and Merging:&lt;/strong&gt; In Git, branches represent parallel lines of development (Partners). When a developer commits changes to a branch, the Git repository acts as the &lt;code&gt;SharedState&lt;/code&gt;, holding the history. Merging brings these partners back together, resolving conflicts based on the current &lt;code&gt;SharedState&lt;/code&gt; and creating a new state. Each branch operates independently until the merge process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Microservices with Event Sourcing:&lt;/strong&gt; Multiple microservices (Partners) can operate independently, but need to react to events happening in other services. A shared event store (e.g., Kafka, Redis Pub/Sub) acts as the &lt;code&gt;SharedState&lt;/code&gt;, publishing events when the state changes. Each microservice subscribes to relevant events and updates its own internal state accordingly. This allows for loose coupling and asynchronous communication between partners.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Infrastructure as Code</title><link>https://swpatterns.com/pattern/infrastructure_as_code/</link><pubDate>Thu, 29 Feb 2024 16:24:00 +0000</pubDate><guid>https://swpatterns.com/pattern/infrastructure_as_code/</guid><description>
&lt;p&gt;Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure through code, rather than through manual processes. This means that infrastructure – servers, virtual machines, networks, load balancers, databases, etc. – is treated as code, stored in version control, and automated through continuous integration/continuous delivery pipelines. IaC promotes consistency, speed, and reduces errors by automating infrastructure setup and changes.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;IaC is crucial for modern DevOps practices and cloud environments. It’s commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cloud Provisioning:&lt;/strong&gt; Automating the creation and management of resources on platforms like AWS, Azure, and Google Cloud.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Application Deployment Pipelines:&lt;/strong&gt; Integrating infrastructure changes seamlessly into deployment processes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disaster Recovery:&lt;/strong&gt; Easily recreating infrastructure in a different location.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Configuration Management:&lt;/strong&gt; Ensuring consistent configurations across all servers and environments.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Test Environments:&lt;/strong&gt; Rapidly creating and destroying test environments as needed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Terraform (HashiCorp):&lt;/strong&gt; Terraform is a popular open-source IaC tool that allows users to define infrastructure in a declarative configuration language (HCL). It supports multiple cloud providers and has a robust ecosystem of modules for common patterns. For instance, a Terraform script can define an entire AWS VPC with subnets, security groups, and EC2 instances, then provision all those resources with a single command like &lt;code&gt;terraform apply&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AWS CloudFormation:&lt;/strong&gt; AWS CloudFormation is a native IaC service within Amazon Web Services. Users define their infrastructure using YAML or JSON templates, detailing the AWS resources needed. CloudFormation then provisions and manages those resources, handling dependencies and updates. For example, setting up a containerized application using ECS and related resources (VPC, security groups, load balancers) can be entirely automated via a CloudFormation template.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ansible (Red Hat):&lt;/strong&gt; While capable of configuration management, Ansible is also frequently used for IaC. It&amp;rsquo;s agentless and uses a simple YAML-based playbook syntax to define infrastructure state. It can be used to install software, configure services, and provision cloud resources, like within Azure, making it suitable for defining the setup of virtual machines and network configurations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Self-Contained Systems</title><link>https://swpatterns.com/pattern/self-contained_systems/</link><pubDate>Thu, 29 Feb 2024 16:23:00 +0000</pubDate><guid>https://swpatterns.com/pattern/self-contained_systems/</guid><description>
&lt;p&gt;Self-Contained Systems is an architectural pattern where an application is structured as a suite of independently deployable services, each with its own database and logic. These systems are designed to be loosely coupled, communicating with each other via well-defined APIs, but without sharing databases or internal state. This approach promotes autonomy, allowing teams to develop, deploy, and scale individual systems independently.&lt;/p&gt;
&lt;p&gt;The core principle is to minimize dependencies between components. Each system is responsible for its own data consistency and availability. This contrasts with monolithic architectures or shared-database approaches, where changes in one part of the system can have cascading effects on others. This pattern is often used in microservice architectures, but can be applied at a coarser granularity as well.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;This pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microservice Architectures:&lt;/strong&gt; The most prevalent use case, where each microservice embodies a self-contained system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Large-Scale Applications:&lt;/strong&gt; Breaking down a large application into smaller, manageable systems improves maintainability and scalability.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Organizations with Multiple Teams:&lt;/strong&gt; Allows teams to own and operate their systems independently, fostering agility and ownership.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Systems Requiring High Availability:&lt;/strong&gt; Isolating failures within a single system prevents them from impacting the entire application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event-Driven Architectures:&lt;/strong&gt; Systems can react to events published by other systems without direct coupling.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Netflix:&lt;/strong&gt; Netflix famously adopted a microservice architecture built on self-contained systems. Each component, like the recommendation engine, video encoding pipeline, or user account management, operates as an independent service with its own data store. This allows Netflix to scale individual features based on demand and deploy updates without disrupting the entire platform.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amazon:&lt;/strong&gt; Amazon&amp;rsquo;s e-commerce platform is composed of numerous self-contained systems. For example, the ordering system, the payment processing system, and the shipping system each have their own databases and logic. This separation allows Amazon to handle massive transaction volumes and maintain high availability, even during peak shopping seasons.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shopify:&lt;/strong&gt; Shopify utilizes self-contained systems for different aspects of its platform, such as the storefront, order management, and payment gateway integrations. This allows for independent scaling and development of each feature, catering to the diverse needs of its merchants.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Application Service</title><link>https://swpatterns.com/pattern/application_service/</link><pubDate>Thu, 29 Feb 2024 16:22:30 +0000</pubDate><guid>https://swpatterns.com/pattern/application_service/</guid><description>
&lt;p&gt;The Application Service pattern defines a layer responsible for coordinating the execution of use cases within a domain-driven design (DDD) application. It acts as an intermediary between the presentation layer (UI, API) and the domain layer, encapsulating the application&amp;rsquo;s behavior and orchestrating domain objects to fulfill specific tasks. Crucially, it does &lt;em&gt;not&lt;/em&gt; contain business rules; those reside within the domain objects themselves.&lt;/p&gt;
&lt;p&gt;This pattern promotes separation of concerns, making the application more maintainable and testable. By containing the transaction management and coordination logic in a dedicated service layer, the domain layer remains focused on core business logic and doesn&amp;rsquo;t get cluttered with infrastructure concerns. It also provides a clear boundary for applying security, caching, and other cross-cutting concerns.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Application Service pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Web Applications:&lt;/strong&gt; Handling user requests (e.g., creating an account, placing an order) by coordinating domain operations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices:&lt;/strong&gt; Defining public interfaces for services, encapsulating internal domain logic.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Command Query Responsibility Segregation (CQRS):&lt;/strong&gt; Implementing the command side, receiving commands from the UI and orchestrating actions on the domain.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event-Driven Systems:&lt;/strong&gt; Receiving events from external sources and initiating domain workflows.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Backend for Frontends (BFF):&lt;/strong&gt; Tailoring application logic for specific client applications.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rails (Ruby on Rails):&lt;/strong&gt; Rails&amp;rsquo; concept of “Services” heavily embodies the Application Service pattern. For example, a &lt;code&gt;OrderProcessingService&lt;/code&gt; might handle the entire process of creating an order, validating inventory, charging the customer, and updating the database. The controller receives the user request and delegates to this service.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring (Java Spring Framework):&lt;/strong&gt; In Spring, &lt;code&gt;@Service&lt;/code&gt; annotated classes are frequently used as Application Services. For instance, a &lt;code&gt;UserService&lt;/code&gt; could encapsulate the logic for registering a new user, updating user profiles, or changing passwords. It uses &lt;code&gt;@Autowired&lt;/code&gt; to inject domain repositories and orchestrates those to fulfill user use cases.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Django (Python Django Framework):&lt;/strong&gt; Django uses services (often as functions within &lt;code&gt;services.py&lt;/code&gt; modules or as classes) to encapsulate application-level logic. A &lt;code&gt;PaymentService&lt;/code&gt; might interact with a third-party payment gateway and update order statuses in the database, keeping the core domain models clean.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Policy</title><link>https://swpatterns.com/pattern/policy/</link><pubDate>Thu, 29 Feb 2024 16:10:00 +0000</pubDate><guid>https://swpatterns.com/pattern/policy/</guid><description>
&lt;p&gt;The Policy pattern encapsulates a set of business rules or logic into separate classes, allowing for greater flexibility and maintainability. It defines a family of algorithms (policies) and makes them interchangeable, enabling the selection of the appropriate algorithm at runtime based on context. Rather than hardcoding the logic within a single class or method, the Policy pattern promotes loose coupling and easier modification of behavior without altering the core client code.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Policy pattern is commonly used in scenarios where business rules are complex and subject to change, or when different users or contexts require different behavior. Specific usage examples include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Access Control:&lt;/strong&gt; Determining whether a user has permission to perform a certain action based on their role and other factors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pricing Rules:&lt;/strong&gt; Applying different pricing calculations depending on customer type, location, or purchase volume.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Validation Logic:&lt;/strong&gt; Implementing varied validation rules based on input data source or user preferences.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Workflow Management:&lt;/strong&gt; Executing different steps in a workflow based on the current state of the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gaming AI:&lt;/strong&gt; Modifying AI behavior (e.g., aggression level) based on game difficulty or player actions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Security (Java):&lt;/strong&gt; Spring Security utilizes policies to define access control rules. &lt;code&gt;AccessDecisionManager&lt;/code&gt; interfaces and &lt;code&gt;VoteBased&lt;/code&gt; or &lt;code&gt;AffirmativeBased&lt;/code&gt; access control strategies allow developers to define multiple &lt;code&gt;AccessDecisionVoter&lt;/code&gt; implementations, each representing a specific policy (e.g., role-based, IP address-based). These voters are then dynamically combined to determine access.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GraphQL Authorization (JavaScript/Node.js):&lt;/strong&gt; Many GraphQL server libraries offer mechanisms for implementing authorization policies. For instance, Apollo Server allows you to define resolver functions with rules that dictate which users can access specific fields or data. These rules can be implemented as separate policy classes or functions, promoting modularity and reusability. A policy might check user roles, ownership of data, or other contextual information before granting access.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes Admission Controllers:&lt;/strong&gt; Kubernetes uses admission controllers which can be implemented as policies to enforce specific constraints on resources before they are persisted. These policies can cover security, resource limits, and compliance requirements, ensuring that the cluster operates according to defined rules.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Database per Service</title><link>https://swpatterns.com/pattern/database_per_service/</link><pubDate>Thu, 29 Feb 2024 15:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/database_per_service/</guid><description>
&lt;p&gt;The Database per Service pattern dictates that each microservice should have its own dedicated database. This contrasts with a shared database approach where multiple services access a single database, which is a common anti-pattern in microservice architectures. The key principle is to decouple data storage from the services themselves, allowing each service full control over its data model and technology choices.&lt;/p&gt;
&lt;p&gt;This pattern enhances a microservice&amp;rsquo;s autonomy, resilience, and scalability. Independent databases allow services to evolve without impacting others, support different database technologies best suited for their specific needs, and minimize contention. While it introduces operational complexity, this complexity is often outweighed by the benefits of loose coupling and increased agility.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Database per Service pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microservice Architectures:&lt;/strong&gt; This is the primary use case, where independent services require independent data management.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain-Driven Design (DDD):&lt;/strong&gt; When applying DDD, each bounded context naturally aligns with a dedicated database ensuring data consistency within the context but allowing flexible data representation across different contexts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Large-Scale Web Applications:&lt;/strong&gt; Breaking down monolithic databases into smaller, service-specific databases simplifies scaling, maintenance, and independent deployments.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud-Native Applications:&lt;/strong&gt; The pattern fits well with cloud-based database services that facilitate scaling and management of multiple instances.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Netflix:&lt;/strong&gt; Netflix famously utilizes this pattern. Different functional areas such as user accounts, recommendations, streaming data, and billing, each operate with their own database tailored to their precise requirements. For instance, the recommendation service might employ a graph database for efficient relationship analysis, while the user account service uses a relational database for structured user data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amazon:&lt;/strong&gt; Amazon&amp;rsquo;s e-commerce platform is built on a microservices architecture, and each service (e.g., product catalog, shopping cart, order processing) has its own database. This allows Amazon to scale individual services independently based on demand. Their use of different database technologies (relational, NoSQL, etc.) is also enabled by this pattern, optimised to each service’s workload.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spotify:&lt;/strong&gt; Spotify leverages database per service in their backend. Different microservices like user profiles, music catalog, playlists, and payments each have their own dedicated databases. This separation allows Spotify to update and scale different parts of its application without affecting others.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Event-Carried State Transfer</title><link>https://swpatterns.com/pattern/event-carried_state_transfer/</link><pubDate>Thu, 29 Feb 2024 14:32:51 +0000</pubDate><guid>https://swpatterns.com/pattern/event-carried_state_transfer/</guid><description>
&lt;p&gt;The Event-Carried State Transfer pattern focuses on transferring state between components using events. Instead of directly exposing and modifying an object&amp;rsquo;s state, a component publishes an event that &lt;em&gt;contains&lt;/em&gt; a complete snapshot of the state to be transferred as a Value Object (or Transfer Object). Another component then consumes the event and uses the provided state information to update its own internal representation. This approach promotes loose coupling, as the source component doesn&amp;rsquo;t need to know about the target component or its internal workings, only the event schema.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful in distributed systems, microservices architectures, and CQRS (Command Query Responsibility Segregation) implementations. It helps to avoid tight coupling when maintaining data consistency across different services and facilitates asynchronous communication. Careful consideration needs to be given to event versioning and handling partial state updates, but the benefits in terms of decoupling and scalability often outweigh these concerns.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microservices Communication:&lt;/strong&gt; When multiple microservices need to act upon the same data, this pattern prevents direct database access and ensures each service operates on its own consistent copy of the state.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CQRS Event Stores:&lt;/strong&gt; In CQRS architectures, the command side can publish events that carry the state changes to the query side, enabling efficient updates of read models.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event Sourcing:&lt;/strong&gt; This pattern forms a core element of event sourcing, where the history of state-changing events &lt;em&gt;is&lt;/em&gt; the application state.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain Events:&lt;/strong&gt; Implementing domain events for loosely coupling domain logic within a single application or across microservices.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Kafka with Avro:&lt;/strong&gt; Kafka is frequently used as an event streaming platform. Avro, a data serialization system, is commonly used to define the schema of the state contained within the events. Microservices subscribe to specific Kafka topics and receive Avro-serialized events representing state changes, allowing them to update their local data stores without direct dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ with JSON:&lt;/strong&gt; The RabbitMQ message broker widely leverages events with associated payloads. For example, an e-commerce system might publish an &lt;code&gt;OrderCreated&lt;/code&gt; event containing the complete order details (customer information, products, shipping address) in JSON format. Separate services – a shipping service, a payment service, and a notification service – can subscribe to this event and initiate their respective processes without needing to communicate with the order management service directly after the event occurs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;.NET Mediator Pattern (with events):&lt;/strong&gt; Several .NET libraries, built around the Mediator pattern, use events to propagate state changes. A component raises an event with a payload including the new state. Handlers subscribed to that event can then react accordingly – for instance, updating a cache or triggering an action in another service.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Expand-Contract</title><link>https://swpatterns.com/pattern/expand-contract/</link><pubDate>Thu, 29 Feb 2024 14:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/expand-contract/</guid><description>
&lt;p&gt;The Expand-Contract pattern addresses scenarios where an object’s behavior needs to be dynamically altered by adding or removing components. It&amp;rsquo;s particularly useful when dealing with complex functionality that isn&amp;rsquo;t always required, promoting a lean initial state and deferring the instantiation of potentially expensive resources until needed. This pattern supports scenarios where functionality can be turned on/off or scaled up/down at runtime.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;This pattern is frequently used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Plugin Systems:&lt;/strong&gt; Where new features are added to an application without modifying its core code. The &amp;rsquo;expanding&amp;rsquo; part is loading a new plugin (adding a component), and &amp;lsquo;contracting&amp;rsquo; might be dynamically unloading one.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resource Management:&lt;/strong&gt; Dynamically allocating and deallocating resources based on demand, like adding processing units to handle peak loads or removing them during idle times.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Feature Toggles:&lt;/strong&gt; Turning features on or off at runtime to perform A/B testing or manage rollout schedules. Adding feature code is expansion, removing/disabling is contraction.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices Architecture:&lt;/strong&gt; Services can dynamically add or remove dependencies to handle fluctuating workloads or evolve functionality.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Web Browser Tabs:&lt;/strong&gt; Modern web browsers employ an expand-contract strategy with tabs. Opening a new tab &amp;rsquo;expands&amp;rsquo; the browser&amp;rsquo;s functionality by adding a new rendering engine and associated resources. Closing a tab &amp;lsquo;contracts&amp;rsquo; by releasing those resources. The browser’s core remains stable, only increasing/decreasing complexity as tabs are added/removed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Database Connection Pooling:&lt;/strong&gt; Database connection pools ‘expand’ by creating new connections when demand increases, and ‘contract’ by releasing unused connections back to the pool. This avoids the overhead of constantly establishing and tearing down connections, improving performance. Libraries like HikariCP and Apache DBCP provide implementations of this pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gradle/Maven Plugin Management:&lt;/strong&gt; Build tools like Gradle and Maven allow users to add or remove plugins to customize their build processes. Adding a plugin ‘expands’ the build functionality, while removing a plugin ‘contracts’ it. This provides flexibility without modifying the core build tool.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Actor Model</title><link>https://swpatterns.com/pattern/actor_model/</link><pubDate>Thu, 29 Feb 2024 10:45:00 +0000</pubDate><guid>https://swpatterns.com/pattern/actor_model/</guid><description>
&lt;p&gt;The Actor Model is a concurrent computation model that treats &amp;ldquo;actors&amp;rdquo; as the fundamental units of computation. Actors encapsulate state and behavior, and communicate with each other exclusively through asynchronous message passing. This avoids the complexities of shared mutable state and locks, leading to more robust and scalable concurrent systems. Each actor has a mailbox where incoming messages are queued, and processes them sequentially.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful in building highly concurrent, distributed, and fault-tolerant systems. It&amp;rsquo;s well-suited for scenarios involving many independent, interacting components, such as real-time applications, game servers, and distributed data processing. The Actor Model simplifies reasoning about concurrency by eliminating the need for explicit thread management and synchronization primitives.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Actor Model is widely used in modern concurrent systems for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Building Reactive Systems:&lt;/strong&gt; Handling streams of events and responding to changes in state in a non-blocking manner.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed Systems:&lt;/strong&gt; Facilitating communication and coordination between nodes in a cluster.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Game Development:&lt;/strong&gt; Managing game entities and their interactions concurrently.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices Architecture:&lt;/strong&gt; Implementing individual microservices as actors, promoting isolation and scalability.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real-time Data Processing:&lt;/strong&gt; Processing high volumes of data streams with low latency.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Akka (Java/Scala):&lt;/strong&gt; Akka is a toolkit and runtime for building highly concurrent, distributed, and resilient message-driven applications. It provides a hierarchical actor system, supervision strategies, and various extensions for building complex systems. Akka is used in production at companies like LinkedIn, Netflix, and Airbnb.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Erlang/OTP (Erlang):&lt;/strong&gt; Erlang was one of the earliest languages to embrace the Actor Model. The OTP (Open Telecom Platform) provides a set of libraries and design principles for building fault-tolerant, concurrent systems. Erlang is renowned for its use in telecommunications systems, such as WhatsApp, which relies on Erlang&amp;rsquo;s concurrency and fault tolerance to handle millions of concurrent users.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ray (Python):&lt;/strong&gt; Ray is a unified framework for scaling AI and Python applications. It uses actors as a core abstraction for stateful computations, allowing developers to easily parallelize and distribute their code. Ray is used in reinforcement learning, hyperparameter tuning, and large-scale data processing.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Unit of Work</title><link>https://swpatterns.com/pattern/unit_of_work/</link><pubDate>Thu, 29 Feb 2024 10:35:00 +0000</pubDate><guid>https://swpatterns.com/pattern/unit_of_work/</guid><description>
&lt;p&gt;The Unit of Work pattern is a mechanism to manage a sequence of operations against a data store as a single logical unit. It encapsulates all changes made to persistent objects within a single transaction, ensuring that either all changes are applied successfully, or none are. This is crucial for maintaining data consistency, especially in complex business scenarios involving multiple entities.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful in Domain-Driven Design (DDD) where it helps to maintain the integrity of the domain model. It abstracts the complexities of the underlying data access technology, allowing the domain logic to focus on business rules rather than transaction management. It provides a clear separation between the domain and data access concerns.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Unit of Work pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Database-driven applications:&lt;/strong&gt; Ensuring atomic operations across multiple tables.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object-Relational Mapping (ORM) frameworks:&lt;/strong&gt; Many ORMs (like Hibernate, Entity Framework) internally implement a Unit of Work to track changes and manage transactions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications with complex business rules:&lt;/strong&gt; Guaranteeing that a set of operations representing a business transaction is completed entirely or rolled back in case of failure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices:&lt;/strong&gt; Coordinating data changes across multiple services while preserving eventual consistency.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hibernate (Java ORM):&lt;/strong&gt; Hibernate&amp;rsquo;s &lt;code&gt;Session&lt;/code&gt; object acts as a Unit of Work. All state changes to managed entities within a &lt;code&gt;Session&lt;/code&gt; are tracked and only persisted when &lt;code&gt;session.commit()&lt;/code&gt; is called. If an exception occurs before commit, &lt;code&gt;session.rollback()&lt;/code&gt; is executed, discarding all changes. This ensures consistency even with complex entity relationships.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Entity Framework (C# ORM):&lt;/strong&gt; In Entity Framework, the &lt;code&gt;DbContext&lt;/code&gt; represents the Unit of Work. Changes to entities tracked by the &lt;code&gt;DbContext&lt;/code&gt; are not immediately written to the database. Instead, they are accumulated and applied in a single transaction when &lt;code&gt;SaveChanges()&lt;/code&gt; is called. Entity Framework provides mechanisms for handling concurrent changes and rollback scenarios within the context of the Unit of Work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Symfony Doctrine (PHP Framework):&lt;/strong&gt; Symfony uses Doctrine ORM and its &lt;code&gt;EntityManager&lt;/code&gt; as the Unit of Work. All changes performed on entities managed by the &lt;code&gt;EntityManager&lt;/code&gt; are tracked, and the &lt;code&gt;$entityManager-&amp;gt;flush()&lt;/code&gt; method commits those changes, or a rollback can be triggered if necessary.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Value Object</title><link>https://swpatterns.com/pattern/value_object/</link><pubDate>Thu, 29 Feb 2024 10:31:00 +0000</pubDate><guid>https://swpatterns.com/pattern/value_object/</guid><description>
&lt;p&gt;A Value Object is an object that describes some characteristic of a Domain, but has no concept of identity. Instead of being defined by its unique position in memory (like an Entity), it is defined by the values it &lt;em&gt;holds&lt;/em&gt;. Two Value Objects with the same values are considered equal, and are interchangeable. They are typically immutable – once created, their values cannot be changed.&lt;/p&gt;
&lt;p&gt;Value Objects are important for ensuring data consistency and simplifying logic within a domain model. Operations that might modify a Value Object instead return a new instance with the modified values. This immutability helps prevent unintended side effects and makes reasoning about the code easier. They are frequently used to represent things like dates, currency amounts, addresses, or color, where the semantic meaning lies in the value itself, not in &amp;lsquo;who owns&amp;rsquo; it or a unique ID.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Value Object pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Domain-Driven Design (DDD):&lt;/strong&gt; Representing domain concepts like quantities, measurements, or specifications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Functional Programming:&lt;/strong&gt; Where immutability is a core principle. Value Objects fit naturally into this paradigm.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Validation:&lt;/strong&gt; Encapsulating validation logic within the Value Object itself ensures data integrity.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Representing Simple Data Structures:&lt;/strong&gt; When you need to group related data elements together, but don’t require a unique identity for the group.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java - &lt;code&gt;java.time.LocalDate&lt;/code&gt;:&lt;/strong&gt; The &lt;code&gt;LocalDate&lt;/code&gt; class in Java&amp;rsquo;s &lt;code&gt;java.time&lt;/code&gt; package is a prime example of a Value Object. It represents a date (year, month, day) without any inherent identity. Two &lt;code&gt;LocalDate&lt;/code&gt; instances representing the same date are considered equal and can be used interchangeably. It&amp;rsquo;s also immutable; methods that appear to modify the date actually return &lt;em&gt;new&lt;/em&gt; &lt;code&gt;LocalDate&lt;/code&gt; instances.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JavaScript - &lt;code&gt;lodash.cloneDeep&lt;/code&gt; with Immutable Data:&lt;/strong&gt; Although JavaScript doesn’t have built-in immutability, libraries like Immutable.js or using &lt;code&gt;lodash.cloneDeep&lt;/code&gt; to create copies can effectively implement value objects. Consider representing an address as a JavaScript object:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;javascript
const address = {
street: &amp;ldquo;123 Main St&amp;rdquo;,
city: &amp;ldquo;Anytown&amp;rdquo;,
zipCode: &amp;ldquo;12345&amp;rdquo;
};&lt;/p&gt;
&lt;p&gt;// Creating a &amp;ldquo;new&amp;rdquo; address involving a change to the city
const newAddress = { &amp;hellip;address, city: &amp;ldquo;Newtown&amp;rdquo; };&lt;/p&gt;
&lt;p&gt;Here, &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;newAddress&lt;/code&gt; are distinct objects with potentially identical content but both are new instances. This approach is effective for representing values that should not be modified in place. The &lt;code&gt;...address&lt;/code&gt; syntax in Javascript uses the spread operator to create a shallow copy, but for nested objects, leveraging libraries like &lt;code&gt;lodash.cloneDeep&lt;/code&gt; to ensure deep immutability is crucial for reliable value object behavior.&lt;/p&gt;</description></item><item><title>Active Record</title><link>https://swpatterns.com/pattern/active_record/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/active_record/</guid><description>
&lt;p&gt;The Active Record pattern is a design pattern where objects representing data, typically database records, carry both data and the logic to interact with the database. Instead of having a separate object to manage database access (like a Data Access Object), the Active Record object itself is responsible for reading and writing its own data.&lt;/p&gt;
&lt;p&gt;This pattern effectively encapsulates database interactions within the domain model, making the code more object-oriented and potentially reducing boilerplate. It simplifies data access by providing methods directly on the object to perform database operations like saving, updating, deleting, and querying.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Active Record pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Object-Relational Mapping (ORM) frameworks:&lt;/strong&gt; It’s the foundation of many ORMs like Ruby on Rails’ ActiveRecord, Django’s models, and SQLAlchemy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data-driven applications:&lt;/strong&gt; Any application where the primary focus is managing data stored in a relational database benefits from this pattern.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simplifying database interactions:&lt;/strong&gt; When you want to minimize the complexity of database access and prefer a more object-centric approach to data management.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rapid development:&lt;/strong&gt; The built-in database functionality accelerates development by reducing the custom code needed for simple CRUD operations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ruby on Rails ActiveRecord:&lt;/strong&gt; In Rails, every model class inherits from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. You define database tables with migrations, and then create Ruby classes that correspond to those tables. Instances of these classes represent rows in the table and have methods like &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;destroy&lt;/code&gt;, and &lt;code&gt;find&lt;/code&gt; to interact with the database. For example, a &lt;code&gt;User&lt;/code&gt; class would automatically have methods to fetch, create, update, and delete user records.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Django ORM:&lt;/strong&gt; Django&amp;rsquo;s ORM utilizes the Active Record pattern through its &lt;code&gt;models.py&lt;/code&gt; files. Each Python class defining a model (representing a database table) automatically gains database interaction abilities. You define fields that map to database columns, and Django provides methods to query and manipulate the data, such as &lt;code&gt;save()&lt;/code&gt;, &lt;code&gt;objects.get()&lt;/code&gt;, and &lt;code&gt;objects.filter()&lt;/code&gt;. A &lt;code&gt;Product&lt;/code&gt; model inherits these capabilities.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SQLAlchemy (Python):&lt;/strong&gt; While more flexible than rigid Active Record implementations, SQLAlchemy can be used in a way that approximates Active Record. By defining classes that map to database tables and using &lt;code&gt;Session&lt;/code&gt; objects to manage those classes, you can treat instances of these classes as directly responsible for their own persistence, akin to the Active Record approach.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Aggregate Root</title><link>https://swpatterns.com/pattern/aggregate_root/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/aggregate_root/</guid><description>
&lt;p&gt;The Aggregate Root pattern is a core concept in Domain-Driven Design (DDD) used to define transactional consistency boundaries. It designates a specific entity within a cluster of associated objects (the aggregate) as the single point of access for modifying the aggregate’s state. This root is responsible for ensuring that all invariants within the aggregate are maintained.&lt;/p&gt;
&lt;p&gt;Aggregates model consistency boundaries. Instead of individual persistence of each entity within the aggregate, the aggregate root handles the persistence of the entire aggregate, preserving its internal relationships and rules. This reduces complexity and prevents inconsistencies that could arise from separate updates. Clients should only hold references to the Aggregate Root, not to individual members.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Aggregate Root pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;E-commerce systems:&lt;/strong&gt; An &lt;code&gt;Order&lt;/code&gt; might be an aggregate root containing &lt;code&gt;OrderItem&lt;/code&gt;s and &lt;code&gt;ShippingAddress&lt;/code&gt; as members. All changes to the order (adding items, changing address, etc.) would be done through the &lt;code&gt;Order&lt;/code&gt; object.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Banking applications:&lt;/strong&gt; An &lt;code&gt;Account&lt;/code&gt; could be an aggregate root with &lt;code&gt;Transaction&lt;/code&gt;s as members. Deposits, withdrawals, and transfers would be handled by the &lt;code&gt;Account&lt;/code&gt; including ensuring sufficient funds.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inventory management:&lt;/strong&gt; A &lt;code&gt;Product&lt;/code&gt; might be an aggregate root containing details such as &lt;code&gt;StockLevel&lt;/code&gt; or related &lt;code&gt;Attributes&lt;/code&gt;. Modifying product information would go through the &lt;code&gt;Product&lt;/code&gt; root.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Any complex domain model:&lt;/strong&gt; Whenever a set of entities are logically related and need to be treated as a single unit for data consistency.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java Persistence API (JPA) with DDD:&lt;/strong&gt; In a JPA implementation using DDD principles, a domain object like &lt;code&gt;Customer&lt;/code&gt; could be the aggregate root. Related entities such as &lt;code&gt;Address&lt;/code&gt; and &lt;code&gt;ContactDetails&lt;/code&gt; would be aggregate members. Using &lt;code&gt;@Entity&lt;/code&gt; annotation on the &lt;code&gt;Customer&lt;/code&gt; and not on &lt;code&gt;Address&lt;/code&gt; nor &lt;code&gt;ContactDetails&lt;/code&gt; (mapping them as embedded objects) enforces the boundary. All changes to the address or contact details would be made through methods on the &lt;code&gt;Customer&lt;/code&gt; object.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Microsoft Entity Framework Core with DDD:&lt;/strong&gt; Similar to JPA, Entity Framework Core can be used to implement the Aggregate Root pattern. A &lt;code&gt;ShoppingCart&lt;/code&gt; class, annotated with &lt;code&gt;[Entity]&lt;/code&gt;, could serve as the aggregate root containing member classes like &lt;code&gt;ShoppingCartItem&lt;/code&gt;. The framework would then treat the &lt;code&gt;ShoppingCart&lt;/code&gt; as a single unit of persistence, preventing direct changes to the items without going through the root. This is commonly seen in e-commerce backends built using EF Core and DDD.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rails Active Record with form objects:&lt;/strong&gt; Although active record isn’t strictly enacting DDD, the idea of insulating a complex model with modifications only applying via a form object acts as a simple Aggregate Root. For example, a &lt;code&gt;User&lt;/code&gt; model might consider an &lt;code&gt;Address&lt;/code&gt; to be part of its aggregate. Updates to addresses would be funnelled through a &lt;code&gt;ChangeAddressForm&lt;/code&gt; object and ultimately applied to the &lt;code&gt;User&lt;/code&gt; record with the &lt;code&gt;Address&lt;/code&gt; data integrated.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Anti-Corruption Layer</title><link>https://swpatterns.com/pattern/anti-corruption_layer/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/anti-corruption_layer/</guid><description>
&lt;p&gt;The Anti-Corruption Layer (ACL) is an architectural pattern used to isolate a core application from problematic or poorly understood external systems (often legacy systems). It acts as a translation layer, preventing the complexities, inconsistencies, and potential errors of the external system from polluting the domain model of the core application. The ACL ensures that the core application interacts with a clean, well-defined interface, shielding it from changes in the external system.&lt;/p&gt;
&lt;p&gt;This pattern is crucial when integrating with systems that are difficult to modify, have unreliable data, or use conflicting concepts. By containing the integration logic within the ACL, the core application remains robust and maintainable, even as the external system evolves. The ACL focuses on fulfilling the core application&amp;rsquo;s needs, rather than mirroring the external system&amp;rsquo;s structure and behavior precisely.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Anti-Corruption Layer is commonly utilized in the following scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Legacy System Integration:&lt;/strong&gt; Integrating a modern application with older, monolithic systems where direct access to the database or internal logic is undesirable or impossible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Third-Party API Wrappers:&lt;/strong&gt; When consuming external APIs that have poorly designed interfaces, inconsistent data formats, or rate limits that need to be managed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservice Communication:&lt;/strong&gt; Acting as a facade or adapter between microservices with differing data models or communication protocols. This is particularly useful during incremental migration to microservices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Migration:&lt;/strong&gt; A temporary layer is used to massage data during influx into a new system.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rails ActiveModel Serializers with Legacy Database:&lt;/strong&gt; In Ruby on Rails, when integrating with a legacy database with a convoluted schema, &lt;code&gt;ActiveModel::Serializers&lt;/code&gt; can form an ACL. The serializer translates the legacy database records into a clean, simplified JSON representation tailored for the Rails application&amp;rsquo;s API, hiding the database intricacies from the controllers and views.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AWS Lambda with External SOAP Service:&lt;/strong&gt; When exposing a RESTful API via AWS Lambda that needs to interact with an older SOAP web service, the Lambda function itself can act as the ACL. It receives REST requests, translates them into SOAP requests, calls the SOAP service, and then transforms the SOAP response into a JSON format suitable for the API consumer. This prevents the need for the entire application stack to understand and handle SOAP.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Clean Architecture</title><link>https://swpatterns.com/pattern/clean_architecture/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/clean_architecture/</guid><description>
&lt;p&gt;Clean Architecture is a software design philosophy that emphasizes separation of concerns to achieve high modularity, testability, and maintainability. It proposes structuring an application into concentric layers, with core business logic residing in the innermost layers and external concerns like databases, UI frameworks, and external APIs residing in the outermost layers. Dependencies point inwards, meaning inner layers have no knowledge of outer layers, promoting independence from technology changes and simplifying testing.&lt;/p&gt;
&lt;p&gt;The primary goal of Clean Architecture is to create systems that are independent of frameworks, databases, UI, and any external agency. This independence allows for easier adaptation to changing requirements, improved testability (as business logic can be tested in isolation), and increased flexibility in choosing and swapping out technologies without impacting the core application. It achieves this through a strict dependency rule: source code dependencies can only point inwards.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Clean Architecture is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Large, complex applications:&lt;/strong&gt; Where maintainability and adaptability are crucial over the long term.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications with evolving requirements:&lt;/strong&gt; The decoupled nature allows for changes in one area without cascading effects.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Systems requiring high testability:&lt;/strong&gt; Inner layers can be tested easily without reliance on external dependencies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices architecture:&lt;/strong&gt; Each microservice can be built on Clean Architecture principles for better isolation and independence.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mobile Applications:&lt;/strong&gt; When needing to support multiple platforms (iOS, Android) with shared core logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexagonal Architecture (Ports and Adapters):&lt;/strong&gt; Often considered a specific implementation of Clean Architecture, Hexagonal Architecture, used in many Java and .NET projects, explicitly defines ports (interfaces) that core logic interacts with, and adapters that connect those ports to external systems. Spring Framework often encourages this pattern through its dependency injection capabilities.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Onion Architecture:&lt;/strong&gt; Similar to Clean Architecture, Onion Architecture focuses on placing the core domain logic at the center and building layers of infrastructure around it. ASP.NET Core projects frequently adopt this structure, separating concerns into domain models, application services, and infrastructure layers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SwiftUI and Combine (Apple Ecosystem):&lt;/strong&gt; Apple&amp;rsquo;s SwiftUI and Combine frameworks, while not explicitly enforcing Clean Architecture, lend themselves well to it. The MVVM (Model-View-ViewModel) pattern, often used with these frameworks, can be implemented within the Clean Architecture layers, with the ViewModel residing in the Use Cases layer and the Model representing Entities.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flask/Django with Core Logic Separation (Python Web Frameworks):&lt;/strong&gt; Python web frameworks like Flask and Django can be structured to follow Clean Architecture principles. The core business logic is placed in separate modules, independent of the web framework&amp;rsquo;s specifics, allowing for easier testing and potential migration to other frameworks.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Context Map</title><link>https://swpatterns.com/pattern/context_map/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/context_map/</guid><description>
&lt;p&gt;The Context Map pattern is a strategic design technique for managing the complexity of a large domain by explicitly defining the boundaries between different areas of responsibility – Bounded Contexts. It visually represents the relationships and dependencies between these contexts, focusing on how they interact and influence each other. By clarifying these connections, it helps avoid integration issues, promotes autonomous teams, and aligns software development with business goals.&lt;/p&gt;
&lt;p&gt;This pattern doesn&amp;rsquo;t prescribe &lt;em&gt;how&lt;/em&gt; contexts are integrated (e.g., APIs, events), but rather &lt;em&gt;that&lt;/em&gt; their relationships are understood and documented. A context map helps organizations prioritize integration efforts, identify potential bottlenecks, and make informed decisions about system ownership, data consistency, and overall architecture. It’s a communication tool as much as a technical one.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Context Map is used in large organizations or projects with complex domains. Common scenarios include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microservice architecture:&lt;/strong&gt; Defining clear boundaries services and the nature of their communication.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiple teams working on a single product:&lt;/strong&gt; Giving each team autonomy over its own domain model and integration points.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mergers and acquisitions:&lt;/strong&gt; Integrating disparate systems and understanding the overlap or gaps in their functionality.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Legacy system modernization:&lt;/strong&gt; Breaking down monolithic applications into manageable, contextually aligned components.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Large-scale distributed systems:&lt;/strong&gt; Understanding the relationship between different systems and managing data flow.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Amazon:&lt;/strong&gt; Amazon&amp;rsquo;s domain is vast. A context map would identify Bounded Contexts like &amp;ldquo;Order Management,&amp;rdquo; &amp;ldquo;Inventory,&amp;rdquo; &amp;ldquo;Payment Processing,&amp;rdquo; &amp;ldquo;Shipping,&amp;rdquo; and &amp;ldquo;Customer Profiles.&amp;rdquo; The relationships would demonstrate how these contexts interact – for example, &amp;ldquo;Order Management&amp;rdquo; uses the &amp;ldquo;Inventory&amp;rdquo; context to check product availability and the &amp;ldquo;Payment Processing&amp;rdquo; context for payment authorization. Each context is likely managed by a separate team, with specific data ownership and models.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spotify:&lt;/strong&gt; Spotify can be broken down into Bounded Contexts such as “User Accounts,” “Music Catalog,” “Playlist Management,” “Recommendation Engine,” and &amp;ldquo;Payment/Subscription&amp;rdquo;. The “Recommendation Engine” relies heavily on data from “Playlist Management” and “User Accounts,” illustrating a strong dependency. Each context has a dedicated team and specific domain experts shaping its evolution, while the Context Map details how these parts fit together into a cohesive music streaming platform.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>CQRS</title><link>https://swpatterns.com/pattern/cqrs/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/cqrs/</guid><description>
&lt;p&gt;CQRS (Command Query Responsibility Segregation) is an architectural pattern that separates read and write operations for a data store. Instead of a single data model and access layer handling both reads and writes, CQRS advocates for using two distinct models: one optimized for handling commands (writes, updates, deletes) and another optimized for handling queries (reads). This separation allows for optimization of each side independently.&lt;/p&gt;
&lt;p&gt;The core principle is to tailor the data structures and logic for what each side &lt;em&gt;needs&lt;/em&gt; to do, rather than forcing a compromise. This often involves using different databases – potentially even different &lt;em&gt;types&lt;/em&gt; of databases – for the read and write sides, enabling technologies best suited to each task. While increasing complexity, CQRS can significantly improve performance, scalability, and security in certain applications.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;CQRS is particularly useful in scenarios with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;High Read/Write Ratios:&lt;/strong&gt; Systems with far more read operations than writes benefit from a read-optimized model.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Domains:&lt;/strong&gt; When the business logic is complex, separating concerns can dramatically simplify overall architecture.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eventual Consistency:&lt;/strong&gt; If strict consistency isn&amp;rsquo;t required, CQRS can leverage asynchronous update mechanisms for better scalability.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scalability Requirements:&lt;/strong&gt; Independent scaling of read and write operations is achievable.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security Concerns:&lt;/strong&gt; Fine-grained control over access to data can be implemented on each side.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Event Store/GetEventStore:&lt;/strong&gt; This event sourcing database and framework inherently embraces CQRS. Commands are used to append new events, and queries (often materializing projections) are used to read the current state. The write side is event-driven, and the read side consists of various projections suitable for different query needs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Railscasts - CQRS:&lt;/strong&gt; The classic Railscasts episode on CQRS (&lt;a href="https://railscasts.com/episodes/338-cqrs"&gt;https://railscasts.com/episodes/338-cqrs&lt;/a&gt;) demonstrates a simple implementation in Ruby on Rails for a blog system. Posts are created/updated via commands, and a separate system builds and manages read models for displaying blog posts efficiently. The read model is rebuilt asynchronously from the event stream.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Azure Cosmos DB:&lt;/strong&gt; While not strictly CQRS, Cosmos DB&amp;rsquo;s ability to have multiple, independent write regions, and globally distributed read regions aligns well with CQRS principles. You can write to one region and let the data be replicated globally for low-latency reads. This supports the separation of concerns and optimization for different operations.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Domain Event</title><link>https://swpatterns.com/pattern/domain_event/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/domain_event/</guid><description>
&lt;p&gt;The Domain Event pattern is a powerful technique in Domain-Driven Design (DDD) used to represent things that &lt;em&gt;have happened&lt;/em&gt; within the domain. Instead of objects directly calling methods on other objects, a Domain Event is raised when a significant state change occurs. Interested parties (handlers) then subscribe to these events and react accordingly, promoting loose coupling and maintainability. This approach ensures that the core domain logic remains clean and focused on its responsibilities, avoiding direct dependencies on infrastructure or other domain parts.&lt;/p&gt;
&lt;p&gt;This pattern excels in systems requiring audit trails, integration with external systems, or triggering side effects within the application. It decouples the &amp;ldquo;what happened&amp;rdquo; (the event) from the &amp;ldquo;how to react&amp;rdquo; (the handlers), which allows for flexibility and extensibility. The pattern aids in building more observable and reactive systems, making it easier to understand the flow of operations and respond to key domain changes.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Auditing:&lt;/strong&gt; Tracking all meaningful state changes in a domain for regulatory compliance or debugging.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Integration:&lt;/strong&gt; Notifying other services or applications about domain changes without tight coupling. For instance, notifying a notification service when an order is placed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Business Rules Enforcement:&lt;/strong&gt; Implementing complex, cross-cutting business rules that span multiple aggregates.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read Model Updates:&lt;/strong&gt; Keeping denormalized read models synchronized with the domain&amp;rsquo;s state.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Workflow Automation:&lt;/strong&gt; Triggering automated processes based on specific events within the domain.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Event Sourcing with Axon Framework (Java):&lt;/strong&gt; Axon Framework heavily relies on Domain Events. Every change to an aggregate is represented as an Event, which is then stored in an Event Store. Axon provides mechanisms to subscribe to these events and update read models or trigger other actions. This is a core aspect of how Axon implements CQRS and Event Sourcing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MassTransit (C#):&lt;/strong&gt; MassTransit is a .NET message bus that can be used to publish and subscribe to Domain Events. It’s a popular choice for implementing event-driven architectures within a .NET ecosystem. When a domain event occurs, it’s published to the message bus, and any consumers interested in that event type handle it, allowing for asynchronous communication and decoupled services.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rails ActiveJob (Ruby):&lt;/strong&gt; Though not strictly “Domain Events” in DDD terminology, Rails&amp;rsquo; ActiveJob allows developers to defer work until later by queueing jobs. By creating jobs that correspond to key domain changes (e.g., &lt;code&gt;OrderCreatedJob&lt;/code&gt;, &lt;code&gt;UserRegisteredJob&lt;/code&gt;), you effectively implement a similar pattern of reacting to state changes without direct coupling.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Hexagonal Architecture</title><link>https://swpatterns.com/pattern/hexagonal_architecture/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/hexagonal_architecture/</guid><description>
&lt;p&gt;The Hexagonal Architecture (also known as Ports and Adapters) is a software design pattern that aims to create loosely coupled software applications with a clear separation of concerns. The core business logic is kept independent of external technologies like databases, UI frameworks, or messaging systems. This is achieved by defining “ports” (interfaces) that represent interactions with the outside world and “adapters” that implement these ports for specific technologies.&lt;/p&gt;
&lt;p&gt;Essentially, the application’s core doesn’t &lt;em&gt;know&lt;/em&gt; about the external world; it only interacts through these well-defined ports. This makes the core logic highly testable, maintainable, and adaptable to changes in external dependencies. Adapters translate the core’s requests into the language of the external system and vice-versa. This pattern promotes testability by allowing you to easily mock or stub external dependencies during testing.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Hexagonal Architecture is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complex Business Logic:&lt;/strong&gt; Applications with substantial domain logic benefit greatly from the clear separation of concerns.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices:&lt;/strong&gt; The pattern’s focus on isolation aligns well with the microservices approach.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Long-Lived Applications:&lt;/strong&gt; Where requirements and external technologies are likely to evolve over time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Test-Driven Development:&lt;/strong&gt; The clear interfaces facilitate easy unit and integration testing.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Systems Requiring Flexibility:&lt;/strong&gt; When you anticipate needing to switch databases, UI frameworks, or integrate with various external systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot (Java):&lt;/strong&gt; Spring’s dependency injection and interface-based programming naturally lend themselves to Hexagonal Architecture. You can define interfaces for repositories (ports) and then provide different implementations (adapters) for different databases (e.g., JPA, MongoDB). Spring Data REST further simplifies creating APIs that interact with these ports.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NestJS (Node.js):&lt;/strong&gt; NestJS, a progressive Node.js framework, encourages the use of modules and providers, which can be structured to implement the Ports and Adapters pattern. Services define the core logic and interact with repositories (ports) through interfaces. Different database technologies can be plugged in as adapters to these repository interfaces.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Laravel (PHP):&lt;/strong&gt; While not strictly enforced, Laravel&amp;rsquo;s service container and interface-based contracts allow developers to implement Hexagonal Architecture. Repositories can be defined as interfaces, and different database implementations can be bound to those interfaces. Event dispatching can be used to represent domain events.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Microkernel</title><link>https://swpatterns.com/pattern/microkernel/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/microkernel/</guid><description>
&lt;p&gt;The Microkernel pattern is an architectural style that structures an application as a core system with minimal functionality, surrounded by plugins or extensions that provide additional features. The core handles essential operations and communication, while plugins implement specific functionalities. This separation promotes modularity, flexibility, and extensibility.&lt;/p&gt;
&lt;p&gt;This pattern allows for easy addition or removal of features without modifying the core system. It also enables independent development and deployment of plugins, making the application more adaptable to changing requirements. The core remains stable, reducing the risk of introducing bugs with new features.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Microkernel pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Operating Systems:&lt;/strong&gt; Many modern operating systems (like macOS, Windows NT) employ a microkernel architecture, separating core kernel functions from device drivers and user services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Application Frameworks:&lt;/strong&gt; Frameworks like Eclipse and the OSGi runtime use microkernels to allow developers to add functionality through plugins.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Large-Scale Applications:&lt;/strong&gt; Complex applications benefit from the modularity and maintainability offered by a microkernel architecture.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event-Driven Systems:&lt;/strong&gt; The core can act as an event bus, and plugins can subscribe to and handle specific events.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Plugin Systems:&lt;/strong&gt; Any application needing a flexible plugin system can leverage this pattern.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Eclipse IDE:&lt;/strong&gt; Eclipse is built around a microkernel. The core platform provides basic functionalities like the workspace, UI, and plugin management. Features like Java development, Git integration, and debugging are implemented as separate plugins that can be installed and uninstalled as needed. This allows users to customize the IDE to their specific needs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;macOS:&lt;/strong&gt; macOS utilizes a hybrid kernel based on the XNU kernel, which has microkernel characteristics. Core services like process management and memory management reside in the kernel, while most other functionalities, such as file systems and device drivers, are implemented as user-space processes that communicate with the kernel through well-defined interfaces. This design enhances stability and security.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WordPress:&lt;/strong&gt; WordPress is a popular content management system that uses a microkernel architecture. The core WordPress installation provides the basic framework for managing content, while themes and plugins extend its functionality to create different types of websites and add features like e-commerce, social media integration, and SEO tools.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Onion Architecture</title><link>https://swpatterns.com/pattern/onion_architecture/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/onion_architecture/</guid><description>
&lt;p&gt;Onion Architecture is a software design pattern that advocates for separating concerns into distinct layers, with the core business logic residing at the very center. This central core is independent of any external concerns like databases, UI frameworks, or external services. Layers represent different levels of abstraction, and dependencies point &lt;em&gt;inward&lt;/em&gt; – outer layers depend on inner layers, but inner layers have no knowledge of outer layers.&lt;/p&gt;
&lt;p&gt;This architecture promotes testability, maintainability, and flexibility. By isolating the domain logic, changes to infrastructure or presentation layers don&amp;rsquo;t impact the core functionality. It&amp;rsquo;s particularly useful in complex applications where business rules are expected to evolve independently of the technology stack.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Onion Architecture is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Enterprise Applications:&lt;/strong&gt; Where complex business rules and long-term maintainability are crucial.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices:&lt;/strong&gt; To ensure each service has a well-defined core and can be adapted to different technologies without affecting other services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain-Driven Design (DDD) Projects:&lt;/strong&gt; It provides a natural structure for implementing DDD principles, keeping the domain model pure and independent.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications requiring high testability:&lt;/strong&gt; The decoupled nature of the layers makes unit testing much easier.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexagonal Architecture (Ports and Adapters):&lt;/strong&gt; Often considered a close relative, Hexagonal Architecture shares the same core principles of dependency inversion and isolating the domain. Many .NET projects utilizing DDD adopt a variation of Onion Architecture, sometimes referred to as &amp;ldquo;Clean Architecture&amp;rdquo; which is heavily influenced by Robert C. Martin&amp;rsquo;s work and builds upon the Onion Architecture principles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASP.NET Core with MediatR:&lt;/strong&gt; A typical implementation involves a Core layer containing entities and interfaces, a Domain layer with business logic, an Application layer using MediatR for commands and queries, and an Infrastructure layer for database access and external service integrations. The Presentation layer (e.g., an ASP.NET Core API) then interacts with the Application layer.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Repository</title><link>https://swpatterns.com/pattern/repository/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/repository/</guid><description>
&lt;p&gt;The Repository pattern provides an abstraction layer between the domain logic and the data access layer. It encapsulates the complexities of data access, allowing the domain to work with objects without knowing how they are stored or retrieved. This promotes loose coupling, making the application easier to test, maintain, and evolve, as changes to the data access implementation don&amp;rsquo;t necessarily impact the domain logic.&lt;/p&gt;
&lt;p&gt;Essentially, the repository acts as a collection of domain objects, providing methods for retrieving, adding, updating, and deleting these objects. It shields the rest of the application from the specifics of the underlying data store (e.g., relational database, NoSQL database, in-memory list). The pattern promotes the Single Responsibility Principle by centralizing data access concerns.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Repository pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Domain-Driven Design (DDD):&lt;/strong&gt; As a core element for separating concerns between the domain model and infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Access Layer (DAL):&lt;/strong&gt; When building applications that need to interact with various data sources.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unit Testing:&lt;/strong&gt; Facilitating the use of mock repositories to isolate unit tests from the real database.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices:&lt;/strong&gt; Allowing individual services to manage their own data persistence without exposing database details to other services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications with complex business rules:&lt;/strong&gt; Where the domain logic should be free from data access concerns.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Entity Framework Core (C#):&lt;/strong&gt; EF Core&amp;rsquo;s &lt;code&gt;DbContext&lt;/code&gt; class, when used in conjunction with repository classes, essentially implements the Repository pattern. The &lt;code&gt;DbContext&lt;/code&gt; handles the underlying database interactions, while the repository provides an interface for accessing and manipulating entities without directly exposing database queries.&lt;/p&gt;
&lt;p&gt;csharp
public interface IProductRepository
{
IEnumerable&lt;!-- raw HTML omitted --&gt; GetAll();
Product GetById(int id);
void Add(Product product);
void Update(Product product);
void Delete(Product product);
}&lt;/p&gt;
&lt;p&gt;public class ProductRepository : IProductRepository
{
private readonly ApplicationDbContext _context;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ProductRepository(ApplicationDbContext context)
{
_context = context;
}
// Implementation using _context to interact with the database
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Django ORM (Python):&lt;/strong&gt; Django’s Model classes and their associated methods (e.g., &lt;code&gt;objects.get()&lt;/code&gt;, &lt;code&gt;objects.filter()&lt;/code&gt;, &lt;code&gt;objects.create()&lt;/code&gt;) act as repositories. While not a strict implementation adhering to a formalized interface, the ORM handles the database interaction, allowing developers to work with Python objects representing database records. Custom model managers can further enhance this behavior, providing more specialized repository-like functionality.&lt;/p&gt;
&lt;p&gt;python
from django.db import models&lt;/p&gt;
&lt;p&gt;class Product(models.Model):
name = models.CharField(max_length=100)
price = models.DecimalField(max_digits=10, decimal_places=2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@classmethod
def get_all(cls):
return cls.objects.all()
@classmethod
def get_by_id(cls, id):
return cls.objects.get(pk=id)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Single Table Inheritance</title><link>https://swpatterns.com/pattern/single_table_inheritance/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/single_table_inheritance/</guid><description>
&lt;p&gt;Single Table Inheritance is a strategy for representing a class hierarchy in a relational database using only one table for all classes in the hierarchy. A “type” column (or discriminator) is added to the table to indicate the specific class of each record. This approach simplifies querying and joins compared to other inheritance mapping strategies, but can lead to a table with many nullable columns if the subclasses have significantly different attributes.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;This pattern is commonly used when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The class hierarchy is relatively small and doesn&amp;rsquo;t have deep nesting.&lt;/li&gt;
&lt;li&gt;Performance is critical, and avoiding joins is a priority.&lt;/li&gt;
&lt;li&gt;The subclasses don&amp;rsquo;t have a large number of unique attributes.&lt;/li&gt;
&lt;li&gt;You want a simple database schema.&lt;/li&gt;
&lt;li&gt;When using Object-Relational Mappers (ORMs) like SQLAlchemy or Django ORM, it&amp;rsquo;s a straightforward way to map inheritance.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Django ORM:&lt;/strong&gt; Django&amp;rsquo;s ORM supports Single Table Inheritance (STI) through its model inheritance feature. A base model defines common fields, and then child models inherit from it, adding their specific fields. Django automatically manages the type/discriminator column and maps records to the appropriate model class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SQLAlchemy:&lt;/strong&gt; SQLAlchemy&amp;rsquo;s &lt;code&gt;single_table_inheritance&lt;/code&gt; option in the &lt;code&gt;__mapper_args__&lt;/code&gt; of a base class allows you to map a class hierarchy to a single table. Similar to Django, a discriminator column is used to identify the class of each row. This is often used when integrating with existing database schemas or when a simple mapping is desired.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Payment Systems:&lt;/strong&gt; Consider a system for processing payments. You might have a base &lt;code&gt;Payment&lt;/code&gt; class with attributes like &lt;code&gt;amount&lt;/code&gt; and &lt;code&gt;date&lt;/code&gt;. Subclasses could be &lt;code&gt;CreditCardPayment&lt;/code&gt; (with &lt;code&gt;card_number&lt;/code&gt;, &lt;code&gt;expiry_date&lt;/code&gt;) and &lt;code&gt;PayPalPayment&lt;/code&gt; (with &lt;code&gt;paypal_transaction_id&lt;/code&gt;). Using STI, all these attributes would reside in a single &lt;code&gt;payments&lt;/code&gt; table, with a &lt;code&gt;payment_type&lt;/code&gt; column indicating which type of payment each row represents.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Specification</title><link>https://swpatterns.com/pattern/specification/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/specification/</guid><description>
&lt;p&gt;The Specification pattern encapsulates business rules in objects, allowing for dynamic combinations and reuse. It’s a way to separate complex logic concerning data from the objects that hold that data. This enables you to define a variety of rules, combine them, and then apply these rules to objects without directly embedding the logic within the object itself.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful in applications with complex validation or filtering requirements. It allows for greater flexibility and maintainability, as rules can be added, modified, or combined without altering the core classes. It&amp;rsquo;s a core pattern in Domain-Driven Design for enriching model objects with behavior and logic.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Specification pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data Validation:&lt;/strong&gt; Defining rules for acceptable data formats, ranges, or dependencies. For example, ensuring an email address is valid or a password meets complexity requirements.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Business Rules Engines:&lt;/strong&gt; Implementing complex decision-making logic based on various criteria.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Querying and Filtering:&lt;/strong&gt; Constructing dynamic queries to retrieve data based on specific conditions. This is common in ORM frameworks and data access layers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Access Control:&lt;/strong&gt; Determining whether a user has permission to perform a certain action based on their role and the resource they are trying to access.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hibernate (Java ORM):&lt;/strong&gt; Hibernate utilizes Specifications as part of its Criteria API. Users define criteria by creating &lt;code&gt;Predicate&lt;/code&gt; objects representing constraints on entity properties. These predicates can be combined using logical operators like &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; to form complex queries. The &lt;code&gt;Criteria&lt;/code&gt; object essentially &lt;em&gt;is&lt;/em&gt; a Specification, defining the conditions for data retrieval.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Doctrine (PHP ORM):&lt;/strong&gt; Similar to Hibernate, Doctrine allows building queries using a &lt;code&gt;Where&lt;/code&gt; clause which essentially models a Specification. You can define conditions on entity attributes and combine them using logical operators, enabling flexible filtering of results. The &lt;code&gt;QueryBuilder&lt;/code&gt;&amp;rsquo;s &lt;code&gt;where()&lt;/code&gt; method accepts specifications, dynamically building up the query.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Strategy Registry</title><link>https://swpatterns.com/pattern/strategy_registry/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/strategy_registry/</guid><description>
&lt;p&gt;The Strategy Registry pattern provides a centralized way to manage and access a collection of strategy algorithms. Instead of a client directly holding references to multiple concrete strategy classes, it interacts with a registry that maps keys (often strings or enums) to specific strategies. This promotes loose coupling, simplifies strategy addition/removal, and enhances maintainability.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful when the number of strategies is dynamic, determined at runtime, or needs to be configured externally. It avoids hardcoding strategy choices within the client and allows for easy extension without modifying existing code. It&amp;rsquo;s a common approach in systems requiring flexible and configurable behavior, such as data processing pipelines, game AI, or payment processing.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Plugin Systems:&lt;/strong&gt; Allowing users to extend functionality by registering their own strategies without modifying the core application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Validation:&lt;/strong&gt; Providing a registry of different validation rules (strategies) that can be applied to data based on its type or context.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Payment Gateways:&lt;/strong&gt; Managing multiple payment processing methods (strategies) through a single interface.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Workflow Engines:&lt;/strong&gt; Dynamically selecting and applying different workflow steps (strategies) based on the current state of the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI and Game Development:&lt;/strong&gt; Selecting different AI behaviors (strategies) for game characters based on game conditions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Jenkins Pipelines:&lt;/strong&gt; Jenkins allows users to define pipelines as code, and these pipelines can utilize different &amp;ldquo;steps&amp;rdquo; or plugins to perform specific tasks. The Jenkins system effectively maintains a registry of available steps, allowing users to dynamically configure the pipeline execution flow. The key is the pipeline script itself, identifying which step (strategy) to execute at a given moment.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring&amp;rsquo;s &lt;code&gt;org.springframework.beans.factory.config.BeanPostProcessor&lt;/code&gt;:&lt;/strong&gt; Spring&amp;rsquo;s BeanPostProcessor interface allows developers to register custom logic to be executed before and after bean instantiation. Spring internally maintains a registry of BeanPostProcessors that are applied to all registered beans in a specific order, effectively selecting strategies (the processors) based on configuration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Log4j/Logback Configurators:&lt;/strong&gt; These logging frameworks use configuration files to define how log messages are handled. The configuration specifies which appenders (strategies) to use based on log level, class name, or other criteria. The framework maintains a registry of appenders and applies them according to the configuration.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>View Store</title><link>https://swpatterns.com/pattern/view_store/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/view_store/</guid><description>
&lt;p&gt;The View Store pattern acts as a mediator between a View (UI) and the underlying application State. It centralizes the logic for preparing data from the State into a ViewModel specifically tailored for the View&amp;rsquo;s needs. Crucially, it also handles user-generated Events from the View, dispatching them to a Reducer which updates the State. This separation of concerns improves testability, maintainability, and allows for complex data transformations without cluttering the View or State.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The View Store pattern is commonly used in modern frontend architectures, particularly those employing unidirectional data flow like Redux, Vuex, or similar state management libraries. It’s applicable when: you need to derive a specific data structure for a UI component from a global application state, you want to encapsulate the logic for handling user interactions and updating the state, and you aim to improve the performance of UI updates by only rendering components when their relevant state changes. It’s often part of implementations of the Model-View-Intent (MVI) or similar reactive patterns.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Redux (JavaScript):&lt;/strong&gt; In Redux, the &lt;code&gt;connect&lt;/code&gt; higher-order component functions as a View Store. It subscribes to the Redux store (State), maps parts of the state to the component&amp;rsquo;s props (ViewModel), and dispatches actions (Events) to the store, which are then handled by Reducers. The &lt;code&gt;connect&lt;/code&gt; function effectively isolates the component from the complexities of the Redux store.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Vuex (Vue.js):&lt;/strong&gt; Vuex utilizes &amp;ldquo;getters&amp;rdquo; which can be considered View Stores. Getters are functions that compute derived state from the Vuex store (State) and return it as a ViewModel for components. Vuex &amp;ldquo;mutations&amp;rdquo; (triggered by &amp;ldquo;actions&amp;rdquo;) act as the Reducers, updating the store&amp;rsquo;s state based on dispatched events. Pinia, a newer state management library for Vue, also employs similar concepts with stores containing both state and actions that function as View Stores.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Domain Service</title><link>https://swpatterns.com/pattern/domain_service/</link><pubDate>Sat, 27 Jan 2024 16:00:00 +0000</pubDate><guid>https://swpatterns.com/pattern/domain_service/</guid><description>
&lt;p&gt;The Domain Service pattern encapsulates complex domain logic that doesn’t naturally belong to any specific entity or value object. It serves as a central point for operations that involve multiple entities or intricate business rules, preventing these behaviors from cluttering up the domain model. This keeps entities focused on their core data and simple behaviors, enhancing maintainability and readability.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;This pattern is beneficial when dealing with transactions spanning multiple entities, calculations requiring data from several domain objects, or orchestration of complex processes within the domain. It&amp;rsquo;s often used in situations where a single entity cannot logically own or implement the required logic. Common use cases include order fulfillment processes, complex pricing calculations, financial transactions, and any significant business workflow.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;E-commerce Order Fulfillment:&lt;/strong&gt; Consider an e-commerce system where fulfilling an order requires updating inventory levels across multiple warehouses, processing payment via a third-party gateway, and creating shipping labels. Each of these operations involves different entities (Order, Product, Warehouse, Payment, Shipment). A &lt;code&gt;OrderFulfillmentService&lt;/code&gt; can orchestrate these steps, ensuring atomicity and consistency without burdening the &lt;code&gt;Order&lt;/code&gt; entity with this complex logic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Banking Account Transfer:&lt;/strong&gt; When transferring funds between bank accounts, several things need to happen: debiting from the source account, crediting to the destination account, and potentially logging the transaction. A &lt;code&gt;FundsTransferService&lt;/code&gt; can be responsible for this operation, ensuring that both debit and credit operations succeed or fail together, thereby maintaining financial consistency. It would interact with &lt;code&gt;Account&lt;/code&gt; entities, potentially a &lt;code&gt;Transaction&lt;/code&gt; entity, and perhaps an &lt;code&gt;AuditLog&lt;/code&gt; service.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Entity</title><link>https://swpatterns.com/pattern/entity/</link><pubDate>Fri, 27 Oct 2023 14:35:00 +0000</pubDate><guid>https://swpatterns.com/pattern/entity/</guid><description>
&lt;p&gt;The Entity pattern represents a real-world object with a distinct identity that persists over time. Entities are defined by their attributes and behaviors, but crucially, they are distinguished from Value Objects by having a unique identifier (ID) that remains constant even if their attributes change. This identity allows for tracking changes and maintaining consistency within a domain model.&lt;/p&gt;
&lt;p&gt;Entities are fundamental in Domain-Driven Design (DDD) and are commonly used in systems where object persistence and tracking are important. They are particularly useful in scenarios involving business rules, data validation, and auditing, as the identity allows for associating history and constraints with specific objects. They are also core to object-relational mapping (ORM) frameworks.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Database Modeling:&lt;/strong&gt; Representing records in a database table. Each entity corresponds to a row, and its ID corresponds to the primary key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Business Domain Logic:&lt;/strong&gt; Modeling core business concepts (e.g., Customer, Product, Order) with unique identities and behaviors relevant to the business.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event Sourcing:&lt;/strong&gt; Entities are used as the state foundation that is changed by events, where their IDs are critical for reconstructing the history.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices:&lt;/strong&gt; Consistent identification of business objects across service boundaries.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java Persistence API (JPA) / Hibernate:&lt;/strong&gt; In JPA and Hibernate, every persistent class is treated as an entity. The &lt;code&gt;@Entity&lt;/code&gt; annotation marks a class as being mapped to a database table. Each entity has an &lt;code&gt;@Id&lt;/code&gt; field which functions as primary key, marking it as identifiable even though other attributes change.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django ORM:&lt;/strong&gt; Django&amp;rsquo;s models are directly mapped to database tables, acting as entities. Each model has a primary key (typically an auto-incrementing integer field) that uniquely identifies each instance, even when it&amp;rsquo;s updated.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ruby on Rails ActiveRecord:&lt;/strong&gt; ActiveRecord models are a direct implementation of the Entity pattern, where each model instance represents a record in a database table and uses a primary key for identification.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Bounded Context</title><link>https://swpatterns.com/pattern/bounded_context/</link><pubDate>Fri, 27 Oct 2023 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/bounded_context/</guid><description>
&lt;p&gt;A Bounded Context is a central concept in Domain-Driven Design. It defines an explicit boundary within which a particular domain model applies. Within a Bounded Context, a specific set of terms and concepts have a precise and consistent meaning. Outside that boundary, those terms may have different meanings, or be irrelevant altogether. This is crucial for managing complexity in large systems.&lt;/p&gt;
&lt;p&gt;The purpose of a Bounded Context is to compartmentalize different aspects of a business domain, preventing the model from becoming a monolithic, unmanageable mess. It enables teams to work independently on different parts of the system without constantly colliding over terminology or logic. Each Bounded Context can have its own unique language (Ubiquitous Language), data schemas, and business rules, all tailored to its specific domain responsibilities.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Bounded Contexts are extremely helpful in situations like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microservices Architecture:&lt;/strong&gt; Each microservice often represents a single Bounded Context, encapsulating a specific business capability.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Large Monolithic Applications:&lt;/strong&gt; Breaking down a large monolith into Bounded Contexts can help to modularize the codebase, making it easier to understand and maintain.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System Integration:&lt;/strong&gt; When integrating different systems, identifying their Bounded Contexts helps define clear integration boundaries and data transformation rules.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Business Domains:&lt;/strong&gt; Any domain with multiple subdomains or areas of responsibility benefits from the explicit delineation that Bounded Contexts provide.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;E-commerce Platform:&lt;/strong&gt; An e-commerce site can be divided into Bounded Contexts such as &amp;ldquo;Catalog,&amp;rdquo; &amp;ldquo;Order Management,&amp;rdquo; &amp;ldquo;Payment,&amp;rdquo; and &amp;ldquo;Shipping.&amp;rdquo; The concept of &amp;ldquo;Product&amp;rdquo; has a different meaning and properties in each context. In the Catalog, it&amp;rsquo;s about descriptions and images. In Order Management, it&amp;rsquo;s about quantities and prices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Healthcare System:&lt;/strong&gt; A healthcare system might have Bounded Contexts for &amp;ldquo;Patient Records,&amp;rdquo; &amp;ldquo;Appointment Scheduling,&amp;rdquo; &amp;ldquo;Billing,&amp;rdquo; and &amp;ldquo;Pharmacy.&amp;rdquo; “Medication” signifies different data and processes in the Pharmacy versus Patient Records contexts. The Pharmacy context focuses on dosage and inventory while Patient Records focuses on allergies and history.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Event Sourcing</title><link>https://swpatterns.com/pattern/event_sourcing/</link><pubDate>Fri, 27 Oct 2023 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/event_sourcing/</guid><description>
&lt;p&gt;Event Sourcing is a pattern where the state of an application is determined not by directly storing the current state, but by storing a sequence of all the changes (events) that have occurred. Instead of asking &amp;ldquo;what is the data &lt;em&gt;now&lt;/em&gt;?&amp;rdquo; you ask &amp;ldquo;what happened &lt;em&gt;then&lt;/em&gt;?&amp;rdquo; and rebuild the state from the events. This provides a complete audit trail, facilitates debugging, allows for temporal queries, and enables replaying events to reconstruct past states or project new read models.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Event Sourcing is commonly used in systems requiring a full audit history, such as financial applications, order management systems, and any domain where understanding &lt;em&gt;how&lt;/em&gt; a state was reached is critical. It’s highly applicable in Domain-Driven Design (DDD) environments, especially for Bounded Contexts representing core business processes. It’s also beneficial in scenarios needing eventual consistency and independence between read and write operations (CQRS). Applications requiring point-in-time consistency or complex state reconstruction find it extremely valuable.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;EventStoreDB:&lt;/strong&gt; A specialized database designed specifically for event sourcing. It efficiently stores, manages, and provides access to event streams. It’s optimized for append-only operations and provides mechanisms for event replay and projection.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka:&lt;/strong&gt; Often used as an event store, although not specifically built for event sourcing, Kafka’s durable, ordered log of events makes it a viable (and scalable) option. Applications can subscribe to these event streams to rebuild state or trigger downstream processes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Axon Framework:&lt;/strong&gt; A Java-based framework that provides tools and features for building event-driven applications using event sourcing and CQRS. It offers abstractions for event handling, state management, and event store integration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rails Event Store:&lt;/strong&gt; A Ruby gem that provides a simple Event Store implementation for Rails applications, useful for adding event sourcing to existing or new projects.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Shared Kernel</title><link>https://swpatterns.com/pattern/shared_kernel/</link><pubDate>Fri, 27 Oct 2023 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/shared_kernel/</guid><description>
&lt;p&gt;The Shared Kernel pattern addresses the challenge of integrating two or more distinct bounded contexts in Domain-Driven Design. It arises when a small, well-defined part of the domain model is inherently shared and crucial to the operation of multiple contexts. Instead of duplicating this logic (leading to inconsistencies) or attempting a full integration (which can create a monolithic system), the Shared Kernel encapsulates this shared domain model within a dedicated kernel, acting as a bridge between the contexts.&lt;/p&gt;
&lt;p&gt;This kernel isn&amp;rsquo;t merely a shared database schema; it encompasses the essential domain objects, rules, and logic that &lt;em&gt;must&lt;/em&gt; be consistent across the participating systems. Other parts of each bounded context remain independent, allowing them to evolve separately. The success of this pattern hinges on keeping the kernel truly small and focusing intensely on the minimal set of concepts that genuinely benefit from shared understanding.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Shared Kernel pattern is commonly used in situations like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microservices Evolution:&lt;/strong&gt; When starting with a monolithic application and breaking it down into microservices, a Shared Kernel can help manage initially overlapping domains.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partner Integrations:&lt;/strong&gt; When integrating with external partners who have a shared understanding of certain domain concepts, a kernel can provide a common language and representation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Legacy System Integration:&lt;/strong&gt; Incorporating pieces of a legacy system’s domain logic into a newer system, while minimizing overall coupling.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Limited Domain Overlap:&lt;/strong&gt; Scenarios where two teams are working on adjacent, but interconnected, parts of a larger business domain with a small area of shared, critical logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;E-commerce and Inventory Management:&lt;/strong&gt; An online e-commerce platform and a separate inventory management system might share a core understanding of &lt;code&gt;Product&lt;/code&gt; (SKU, description, price, basic attributes). Instead of each system maintaining its own potentially divergent &lt;code&gt;Product&lt;/code&gt; model, they could use a Shared Kernel defining this core concept and its invariants. The e-commerce system can then enrich the &lt;code&gt;Product&lt;/code&gt; with marketing data; inventory management with stock levels, while both rely on the shared kernel for fundamental product information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Banking – Accounts and Transactions:&lt;/strong&gt; A banking system may consist of a “Core Banking” system responsible for managing accounts and a “Payments” system handling transaction processing. They share a fundamental understanding of “Money” &amp;amp; “Currency”. A Shared Kernel could model these concepts, ensuring both systems operate on a consistent definition of monetary value, exchange rates, and allowed precision. The Core Banking system might extend &lt;code&gt;Account&lt;/code&gt; with regulatory information; the Payments system with transaction-specific details.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Aggregate</title><link>https://swpatterns.com/pattern/aggregate/</link><pubDate>Fri, 27 Oct 2023 10:00:00 +0000</pubDate><guid>https://swpatterns.com/pattern/aggregate/</guid><description>
&lt;p&gt;The Aggregate pattern is a core concept in Domain-Driven Design (DDD). It defines a cluster of domain objects (Entities and Value Objects) that are treated as a single unit. This unit is responsible for maintaining data consistency within its boundaries and presenting a cohesive interface to the outside world. An Aggregate has one Entity designated as the &amp;ldquo;Aggregate Root&amp;rdquo;, which is the only entry point for modifying the Aggregate’s state.&lt;/p&gt;
&lt;p&gt;The purpose of an Aggregate is to simplify the domain model, reduce complexity, and ensure data integrity. By encapsulating state and behavior, Aggregates prevent distributed transactions and maintain consistency boundaries. This pattern allows you to model complex business rules and relationships in a manageable and maintainable way, particularly crucial in large or evolving domains.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Aggregate pattern is widely used in applications that require strong data consistency, especially those dealing with complex business rules. Common scenarios include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Banking Systems:&lt;/strong&gt; An &amp;ldquo;Account&amp;rdquo; can be an aggregate root, containing entities like &amp;ldquo;Transaction&amp;rdquo; and value objects like &amp;ldquo;Money&amp;rdquo;. Operations like transferring funds necessitate modifying the state of the Account and associated Transactions as a single unit.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E-commerce Order Management:&lt;/strong&gt; An &amp;ldquo;Order&amp;rdquo; is an aggregate root, comprising &amp;ldquo;OrderItems&amp;rdquo;, &amp;ldquo;ShippingAddress&amp;rdquo; (value object), and &amp;ldquo;PaymentInformation&amp;rdquo; (value object). Changes to the order, adding items, or updating the address need to be done through the Order aggregate.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inventory Management:&lt;/strong&gt; A &amp;ldquo;Product&amp;rdquo; or a &amp;ldquo;Warehouse&amp;rdquo; can be an Aggregate Root containing “InventoryItems”. Operations such as adjusting stock levels should treat the entire aggregate as a single unit of change.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Any business process involving cascading changes:&lt;/strong&gt; When a single action impacts multiple related domain objects, an Aggregate pattern can enforce consistency.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java Persistence API (JPA) and Hibernate:&lt;/strong&gt; While not explicitly enforcing the technical pattern, ORM frameworks like Hibernate strongly encourage and support the Aggregate patterns. You typically work with Entities within a transaction as an Aggregate, making changes and persisting them together as one logical unit. Cascade operations (e.g., cascading a save operation from the root to contained entities) effectively manage Aggregate boundaries.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Microsoft Entity Framework Core:&lt;/strong&gt; Similar to JPA/Hibernate, EF Core allows developers to define relationships between entities and manage changes within a transaction. Using &lt;code&gt;DbContext.SaveChanges()&lt;/code&gt; ensures that all changes to related entities within an Aggregate are persisted atomically. Explicitly identifying Aggregate Roots allows for optimized loading and modification of related data.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Axon Framework (Event Sourcing):&lt;/strong&gt; Axon is a Java framework for building event-driven systems. Aggregates are a central concept in Axon, providing a consistent interface for applying commands and handling events while ensuring consistency within the domain. Each Aggregate Root acts as a state machine, transitioning through states based on received commands and publishing events to notify other parts of the system.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Saga (Choreography)</title><link>https://swpatterns.com/pattern/saga_choreography/</link><pubDate>Fri, 27 Oct 2023 10:00:00 +0000</pubDate><guid>https://swpatterns.com/pattern/saga_choreography/</guid><description>
&lt;p&gt;The Saga pattern is a distributed transaction management pattern for coordinating a sequence of local transactions across multiple microservices. Unlike traditional distributed transactions (like two-phase commit), Sagas don&amp;rsquo;t rely on centralized locking or coordination. Instead, each local transaction updates data within a single service, and the Saga coordinates the overall process by defining a series of steps where each step publishes events that trigger the next. If a step fails, the Saga executes a series of compensating transactions to undo the changes made by the preceding steps, ensuring eventual consistency.&lt;/p&gt;
&lt;p&gt;Saga choreography moves the coordination logic &lt;em&gt;into&lt;/em&gt; each service. Each service listens for events from other services and decides when to execute its local transaction. This avoids a central orchestrator but can make the overall flow harder to understand and debug, as the logic is spread across multiple services. It&amp;rsquo;s best suited for simpler, well-defined workflows where dependencies aren&amp;rsquo;t heavily interwoven.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Saga pattern is commonly used in microservices architectures to manage long-lived transactions that span multiple services, particularly in scenarios where traditional ACID transactions are not feasible or desirable. Key use cases include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;E-commerce Order Management:&lt;/strong&gt; Creating an order involves inventory reservation, payment authorization, and shipping scheduling. Each of these can be a separate service, and a Saga ensures that if any step fails, the entire order is rolled back consistently.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Travel Booking:&lt;/strong&gt; Booking a flight, hotel, and rental car often involves interacting with different external services. A Saga can orchestrate thesebookings, ensuring that if one booking fails, the others are cancelled.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Financial Transactions:&lt;/strong&gt; Splitting payments across multiple accounts or services (e.g., a bank transfer involving a fraud check).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Data Pipelines:&lt;/strong&gt; Coordinating updates across various data stores or processing stages.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Axon Framework (Java):&lt;/strong&gt; Axon Framework provides built-in support for Sagas, allowing developers to define Saga logic using annotations or configuration. Axon supports both orchestration and choreography-based Sagas. The framework handles event dispatching and compensating transaction execution, simplifying the implementation of distributed transactions.
&lt;a href="https://axonframework.io/"&gt;axon-framework.org&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Netflix Dastur (Java/Python):&lt;/strong&gt; Although Dastur is a more general-purpose workflow automation tool, it effectively implements the Saga pattern by allowing the creation of composable, event-driven workflows. Netflix used Dastur extensively to manage complex operational tasks and dependencies between various internal services, effectively handling failures and ensuring eventual consistency.
&lt;a href="https://github.com/Netflix/Dastur"&gt;github.com/Netflix/Dastur&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Eventualize (Go):&lt;/strong&gt; Eventualize is a lightweight Go library that provides tools for building event-driven applications, including support for the Saga pattern. It allows developers to define Sagas as a series of event handlers and compensators, simplifying the development and management of distributed transactions, particularly in Kubernetes environments.
&lt;a href="https://github.com/Bit-Monk/Eventualize"&gt;github.com/Bit-Monk/Eventualize&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>