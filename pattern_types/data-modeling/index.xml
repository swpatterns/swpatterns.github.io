<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Modeling Patterns on SWPatterns.com</title><link>http://www.swpatterns.com/pattern_types/data-modeling/</link><description>Recent content in Data Modeling Patterns on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 10:30:00 +0000</lastBuildDate><atom:link href="http://www.swpatterns.com/pattern_types/data-modeling/index.xml" rel="self" type="application/rss+xml"/><item><title>Class Table Inheritance</title><link>http://www.swpatterns.com/pattern/class_table_inheritance/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>http://www.swpatterns.com/pattern/class_table_inheritance/</guid><description>
&lt;p&gt;Class Table Inheritance (CTI) is a database schema design pattern used to represent class hierarchies in a relational database. Instead of creating a separate table for each class in the hierarchy, CTI uses a single table for the base class and all its subclasses. The table contains columns for all attributes of all classes, with subclass-specific attributes being nullable for the base class instances. A discriminator column is used to identify the actual class of each row.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;CTI is useful when you have a relatively small and stable class hierarchy, and when the subclasses don&amp;rsquo;t have many unique attributes. It simplifies queries that need to access common attributes across all classes in the hierarchy. It&amp;rsquo;s often used in scenarios where performance is critical for retrieving base class data, and the overhead of joins is undesirable. However, it can lead to sparse tables with many null values and potential issues with data integrity if not carefully managed.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SQLAlchemy (Python ORM):&lt;/strong&gt; SQLAlchemy&amp;rsquo;s &lt;code&gt;single_table_inheritance&lt;/code&gt; feature implements CTI. You define a base class and subclasses, and SQLAlchemy automatically creates a single table with columns for all attributes, using a &lt;code&gt;__discriminator__&lt;/code&gt; attribute to differentiate between instances of different classes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hibernate (Java ORM):&lt;/strong&gt; Hibernate supports CTI through its inheritance mapping strategies. You can map a class hierarchy to a single table using the &lt;code&gt;@Inheritance(strategy = InheritanceType.SINGLE_TABLE)&lt;/code&gt; annotation. A discriminator column is then used to identify the concrete class of each row.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Database Schema for a Payment System:&lt;/strong&gt; Consider a base class &lt;code&gt;Payment&lt;/code&gt; with attributes like &lt;code&gt;payment_id&lt;/code&gt;, &lt;code&gt;amount&lt;/code&gt;, and &lt;code&gt;payment_date&lt;/code&gt;. Subclasses could be &lt;code&gt;CreditCardPayment&lt;/code&gt; (with &lt;code&gt;card_number&lt;/code&gt;, &lt;code&gt;expiry_date&lt;/code&gt;) and &lt;code&gt;PayPalPayment&lt;/code&gt; (with &lt;code&gt;paypal_transaction_id&lt;/code&gt;). CTI would represent all these in a single &lt;code&gt;Payments&lt;/code&gt; table with columns for all attributes, and a &lt;code&gt;payment_type&lt;/code&gt; column to indicate whether a row represents a &lt;code&gt;CreditCardPayment&lt;/code&gt; or a &lt;code&gt;PayPalPayment&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>