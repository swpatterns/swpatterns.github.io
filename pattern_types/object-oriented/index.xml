<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Object-Oriented Patterns on SWPatterns.com</title><link>http://www.swpatterns.com/pattern_types/object-oriented/</link><description>Recent content in Object-Oriented Patterns on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 16:32:00 +0000</lastBuildDate><atom:link href="http://www.swpatterns.com/pattern_types/object-oriented/index.xml" rel="self" type="application/rss+xml"/><item><title>Branch by Abstraction</title><link>http://www.swpatterns.com/pattern/branch_by_abstraction/</link><pubDate>Thu, 29 Feb 2024 16:32:00 +0000</pubDate><guid>http://www.swpatterns.com/pattern/branch_by_abstraction/</guid><description>
&lt;p&gt;Branch by Abstraction decouples the logic that chooses which implementation to use from the implementations themselves. Instead of using conditional statements (if/else or switch) to select behavior based on type or configuration, it introduces an abstraction (interface or abstract class) and provides different concrete implementations. The client interacts with the abstraction, and the system uses the abstraction to determine which concrete implementation to instantiate and execute, often driven by configuration or environment variables. This allows you to change the behavior of the system at runtime without modifying the client code.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful when you need to switch between different versions of an algorithm or service without causing disruptive changes to the codebase. It is favored in scenarios involving A/B testing, feature toggles, or compatibility with different systems that expect varying interfaces. By isolating the branching logic behind an abstraction, it becomes easier to add new behaviors and manage complexity as the system evolves.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Branch by Abstraction is used frequently in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Database Migrations:&lt;/strong&gt; Switching between different database schemas or accessing data through different ORM layers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A/B Testing:&lt;/strong&gt; Rolling out new features to a subset of users based on configuration, presenting different UI elements.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API Versioning:&lt;/strong&gt; Providing different API implementations based on the requested version, while maintaining a single client-facing interface.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Platform Support:&lt;/strong&gt; Adapting behavior to different operating systems or hardware platforms.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Retrofit (Android Networking Library):&lt;/strong&gt; Retrofit uses Branch by Abstraction with its &lt;code&gt;Converter&lt;/code&gt; system. You define an abstraction for converting JSON responses into data objects. Different &lt;code&gt;Converter&lt;/code&gt; implementations (e.g., GsonConverter, MoshiConverter) handle the actual conversion logic. The client specifies which converter to use through configuration, and Retrofit selects the appropriate implementation without the client needing to know about the different conversion mechanisms.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java&amp;rsquo;s JDBC API:&lt;/strong&gt; The Java Database Connectivity (JDBC) API exemplifies Branch by Abstraction. The &lt;code&gt;java.sql.Connection&lt;/code&gt; interface represents the abstraction for connecting to a database. Different database vendors (MySQL, PostgreSQL, Oracle) provide their specific &lt;code&gt;Driver&lt;/code&gt; implementations. The application uses &lt;code&gt;DriverManager.getConnection()&lt;/code&gt; with a database URL, and the JDBC driver responsible for that URL is loaded and utilized, effectively branching based on the provided connection details. The core application code doesn’t need to be aware of the intricacies of each database backend.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Extension Object</title><link>http://www.swpatterns.com/pattern/extension_object/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>http://www.swpatterns.com/pattern/extension_object/</guid><description>
&lt;p&gt;The Extension Object pattern addresses the problem of adding functionality to existing classes without modifying their core structure. It achieves this by encapsulating varying behaviors into separate extension classes, which are then passed to the client class to execute specific operations. This promotes the Single Responsibility Principle and allows for flexible and dynamic behavior modification.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful when a class has many optional behaviors, and including them all directly would lead to a bloated and complex design. It allows you to add new functionality without altering the original class, making it more maintainable and extensible. It&amp;rsquo;s a common technique for handling variations in reporting, validation, or other auxiliary processes.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Extension Object pattern is commonly used in scenarios where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A class needs to support a variety of optional behaviors.&lt;/li&gt;
&lt;li&gt;You want to avoid a large number of boolean flags or conditional statements within a class.&lt;/li&gt;
&lt;li&gt;You anticipate that new behaviors will be added frequently.&lt;/li&gt;
&lt;li&gt;You want to keep the core class focused on its primary responsibilities.&lt;/li&gt;
&lt;li&gt;It helps decouple the primary logic from supporting concerns and makes testing easier by enabling focused unit tests on extensions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Report Generation in a Financial System:&lt;/strong&gt; Consider a financial system where you need to generate various reports (e.g., Summary, Detailed, Audit). Instead of adding report-generation logic directly into the &lt;code&gt;Transaction&lt;/code&gt; class, you can create separate &lt;code&gt;SummaryReportExtension&lt;/code&gt;, &lt;code&gt;DetailedReportExtension&lt;/code&gt;, and &lt;code&gt;AuditReportExtension&lt;/code&gt; classes. The &lt;code&gt;Transaction&lt;/code&gt; class can then accept an &lt;code&gt;Extension&lt;/code&gt; object specifying which report to generate, achieving flexible reporting without code modification to the central &lt;code&gt;Transaction&lt;/code&gt; class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Django REST Framework (DRF) Serializers:&lt;/strong&gt; DRF utilizes a similar concept when handling serialization options. While the core &lt;code&gt;Serializer&lt;/code&gt; class defines the basic data mapping, additional behaviors like related field expansion or nested serialization are often implemented in separate extension classes (though not explicitly named “Extension Objects”). These extensions are then applied during the serialization process, providing a powerful and modular system for building APIs. For instance, &lt;code&gt;ModelSerializer&lt;/code&gt; extends the base &lt;code&gt;Serializer&lt;/code&gt; to automatically provide data based on a Django model, and further customizations can be achieved through combination of different serializers and extensions.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>