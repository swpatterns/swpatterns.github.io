<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Communication Patterns on SWPatterns.com</title><link>https://www.swpatterns.com/pattern_types/communication/</link><description>Recent content in Communication Patterns on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 16:52:37 +0000</lastBuildDate><atom:link href="https://www.swpatterns.com/pattern_types/communication/index.xml" rel="self" type="application/rss+xml"/><item><title>Mediator</title><link>https://www.swpatterns.com/pattern/mediator/</link><pubDate>Thu, 29 Feb 2024 16:52:37 +0000</pubDate><guid>https://www.swpatterns.com/pattern/mediator/</guid><description>
&lt;p&gt;The Mediator pattern defines an object that encapsulates how a set of objects interact. This mediator promotes loose coupling by preventing objects from referring to each other explicitly and lets the mediation logic vary independently of the interacting objects. Instead of components communicating directly, they communicate through the mediator, which handles the interactions.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Mediator pattern is particularly useful when you have a complex set of objects that interact in many different ways. It helps to centralize the control logic, making the system easier to understand, maintain, and extend. Common scenarios include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chat applications:&lt;/strong&gt; A chat room acts as a mediator between multiple users, handling message distribution.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Air traffic control:&lt;/strong&gt; The control tower mediates communication between airplanes to prevent collisions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Graphical User Interfaces (GUIs):&lt;/strong&gt; A window manager can act as a mediator between different UI elements, handling events and updates.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex workflows:&lt;/strong&gt; When a system needs to orchestrate a series of dependent operations, a mediator can manage the flow of control.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Node.js Event Emitter:&lt;/strong&gt; The Node.js &lt;code&gt;EventEmitter&lt;/code&gt; class can be seen as a simple mediator. Components subscribe to events (through &lt;code&gt;on()&lt;/code&gt;) and the emitter handles dispatching those events to the appropriate listeners (through &lt;code&gt;emit()&lt;/code&gt;). Components donâ€™t need to know about each other; they just interact with the &lt;code&gt;EventEmitter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;javascript
const EventEmitter = require(&amp;rsquo;events&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;class Mediator extends EventEmitter {
notify(event, data) {
this.emit(event, data);
}
}&lt;/p&gt;
&lt;p&gt;class ComponentA {
constructor(mediator) {
this.mediator = mediator;
mediator.on(&amp;rsquo;eventB&amp;rsquo;, (data) =&amp;gt; {
console.log(&amp;lsquo;Component A received eventB:&amp;rsquo;, data);
});
}&lt;/p&gt;
&lt;p&gt;doSomething() {
this.mediator.notify(&amp;rsquo;eventA&amp;rsquo;, &amp;lsquo;Data from A&amp;rsquo;);
}
}&lt;/p&gt;
&lt;p&gt;class ComponentB {
constructor(mediator) {
this.mediator = mediator;
mediator.on(&amp;rsquo;eventA&amp;rsquo;, (data) =&amp;gt; {
console.log(&amp;lsquo;Component B received eventA:&amp;rsquo;, data);
});
}&lt;/p&gt;
&lt;p&gt;doSomethingElse() {
this.mediator.notify(&amp;rsquo;eventB&amp;rsquo;, &amp;lsquo;Data from B&amp;rsquo;);
}
}&lt;/p&gt;
&lt;p&gt;const mediator = new Mediator();
const componentA = new ComponentA(mediator);
const componentB = new ComponentB(mediator);&lt;/p&gt;
&lt;p&gt;componentA.doSomething();
componentB.doSomethingElse();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Android Message Queues (Handler):&lt;/strong&gt; In Android development, the &lt;code&gt;Handler&lt;/code&gt; class and its associated message queues function as a mediator between different threads (especially the UI thread and background threads). A background thread can send messages to the UI thread via a &lt;code&gt;Handler&lt;/code&gt;, without the background thread needing direct access to UI elements or knowing their implementation details.&lt;/p&gt;
&lt;p&gt;java
// Simplified example - In a real Android app, Handlers are more complex
public class Mediator {
private final Handler uiHandler;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Mediator(Handler uiHandler) {
this.uiHandler = uiHandler;
}
public void sendMessage(String message) {
uiHandler.post(() -&amp;gt; {
// Update UI with the message
System.out.println(&amp;quot;UI Thread received: &amp;quot; + message);
});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public class BackgroundTask {
private final Mediator mediator;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BackgroundTask(Mediator mediator) {
this.mediator = mediator;
}
public void doWork() {
// Simulate some work
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
mediator.sendMessage(&amp;quot;Work completed!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Store-and-Forward</title><link>https://www.swpatterns.com/pattern/store-and-forward/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://www.swpatterns.com/pattern/store-and-forward/</guid><description>
&lt;p&gt;The Store-and-Forward pattern is a communication paradigm where an intermediary component receives a complete message from a sender, stores it, and then forwards it to the intended recipient. This decoupling allows the sender and receiver to operate independently, even if they are not simultaneously available. The intermediary acts as a buffer and ensures message delivery, handling potential network issues or receiver unavailability.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;This pattern is widely used in scenarios demanding reliable asynchronous communication. Common applications include email servers (storing emails until the recipient&amp;rsquo;s server is available), message queues (like RabbitMQ or Kafka), and mobile network infrastructure (base stations storing data for mobile devices that move in and out of range). It&amp;rsquo;s also crucial in distributed systems where components might experience intermittent connectivity. For example, applications handling offline processing, data synchronization services, or even chat applications can benefit from it.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Email Systems (SMTP):&lt;/strong&gt; When you send an email, your email client transmits it to an SMTP server (the intermediary). The SMTP server stores the email and attempts to deliver it to the recipient&amp;rsquo;s mail server. If the recipient&amp;rsquo;s server is unavailable, the sending SMTP server holds the message and retries later. This ensures your email eventually reaches its destination, even with temporary network issues.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ/Message Queues:&lt;/strong&gt; RabbitMQ is a popular message broker that utilizes Store-and-Forward. Producers (senders) send messages to RabbitMQ, which stores them in queues. Consumers (receivers) retrieve messages from the queues when they are ready to process them. RabbitMQ guarantees message delivery, even if consumers are temporarily offline, by persisting messages to disk. This is a core component of microservice architectures for asynchronous communication.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>