<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Patterns on SWPatterns.com</title><link>https://swpatterns.com/pattern_types/data/</link><description>Recent content in Data Patterns on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 18:33:45 +0000</lastBuildDate><atom:link href="https://swpatterns.com/pattern_types/data/index.xml" rel="self" type="application/rss+xml"/><item><title>Resequencer</title><link>https://swpatterns.com/pattern/resequencer/</link><pubDate>Thu, 29 Feb 2024 18:33:45 +0000</pubDate><guid>https://swpatterns.com/pattern/resequencer/</guid><description>
&lt;p&gt;The Resequencer pattern addresses the problem of ensuring events are processed in the correct order when dealing with distributed systems or asynchronous processing where event delivery order is not guaranteed. It acts as an intermediary, buffering and reordering events based on a defined sequence identifier before passing them on to the final processor. This is crucial for maintaining data consistency and avoiding unexpected behavior in systems relying on sequential operations.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful in scenarios involving Command Query Responsibility Segregation (CQRS), Event Sourcing, and microservices architectures. Itâ€™s also valuable when integrating with external systems that might not adhere to strict ordering guarantees, or when dealing with events that can arrive &amp;lsquo;out of order&amp;rsquo; due to network latency or processing delays, and where the order of processing is critical for correctness.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Resequencer pattern is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Financial Transaction Processing:&lt;/strong&gt; Ensuring transactions are applied to accounts in the correct order, even if network delays cause them to arrive scrambled.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Log Aggregation and Analysis:&lt;/strong&gt; Ordering log entries from multiple sources by timestamp to reconstruct a proper sequence of events.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Game Development:&lt;/strong&gt; Maintaining the correct order of game actions, especially in multiplayer games, to ensure a consistent game state across clients.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed Databases:&lt;/strong&gt; Handling writes to different shards in a distributed database to achieve total order for specific logical units of operation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Apache Kafka with Kafka Streams:&lt;/strong&gt; Kafka&amp;rsquo;s partitioning allows for parallel processing, but may not guarantee order within a partition. Kafka Streams provides features like windowing and aggregation, which, combined with careful partition key selection, can effectively act as a resequencer, ensuring related events are processed together and in order. Specifically, the &lt;code&gt;KStream&lt;/code&gt;&amp;rsquo;s &lt;code&gt;sort()&lt;/code&gt; operation or using a single partition for related events achieves resequencing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AWS Kinesis Data Streams:&lt;/strong&gt; Kinesis streams ingest data in a sequence, but parallel processing by multiple consumers may lead to out-of-order results. A Kinesis Data Analytics application, or a custom downstream process, can utilize windowing or sessionization techniques along with ordering attributes within the ingested records to re-sequence the data before writing to a final data store like Amazon S3 or DynamoDB. DynamoDB streams alongside Lambda functions can achieve resequencing through a buffer utility using state.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Read Model</title><link>https://swpatterns.com/pattern/read_model/</link><pubDate>Thu, 29 Feb 2024 14:32:00 +0000</pubDate><guid>https://swpatterns.com/pattern/read_model/</guid><description>
&lt;p&gt;The Read Model pattern addresses the performance challenges of querying complex domains by maintaining one or more specialized data stores optimized for specific read operations. Instead of directly querying the primary data store (often an event store or normalized database used by the write side), the read model denormalizes and reshapes data based on anticipated query needs. These read models are updated asynchronously by subscribing to events emitted by the write side, ensuring eventual consistency.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Read Model pattern is particularly useful in systems employing Command Query Responsibility Segregation (CQRS). It&amp;rsquo;s applied when read performance is a critical concern, and the complexity of querying the write database hinders responsiveness. Common scenarios include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reporting and Analytics:&lt;/strong&gt; Building specialized data stores optimized for generating reports and analyzing historical data without impacting the operational database.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User Interface Optimization:&lt;/strong&gt; Creating read models tailored to the data requirements of specific UI components, reducing the amount of data transferred and processed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;High-Volume Read Scenarios:&lt;/strong&gt; When a system experiences significantly more read requests than write requests, a read model can dramatically improve scalability and responsiveness.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Evolving Read Requirements:&lt;/strong&gt; Allows changes to read models without impacting the core write domain logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Event Sourcing with Axon Framework:&lt;/strong&gt; Axon Framework uses event stores as its primary data source. To provide efficient querying, Axon promotes the use of read models that are projections of the event stream. Event handlers subscribe to events and update the read model, which is typically a relational database or a NoSQL document store. This means reads are not querying the event store directly, but an optimized read-only view.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MediatR and CQRS in .NET:&lt;/strong&gt; Many .NET applications leveraging MediatR for command/query handling employ CQRS principles. The Read Model pattern is implemented by creating separate query handlers that fetch data from dedicated read databases (e.g., a document database optimized for searching) rather than relying solely on the transactional database used for commands. This is often coupled with event handlers updating these read databases as state changes occur.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Projection</title><link>https://swpatterns.com/pattern/projection/</link><pubDate>Fri, 27 Oct 2023 14:35:00 +0000</pubDate><guid>https://swpatterns.com/pattern/projection/</guid><description>
&lt;p&gt;The Projection pattern addresses the problem of efficiently delivering only the data required by a client or use case, preventing over-fetching and improving performance. Instead of exposing the entire data model, a &lt;em&gt;projector&lt;/em&gt; transforms the source data into a simplified &lt;em&gt;data view&lt;/em&gt; specifically tailored for the consumer. This enhances decoupling, as changes to the source data model don&amp;rsquo;t necessarily require changes to how the data is consumed.&lt;/p&gt;
&lt;p&gt;This pattern is especially useful in scenarios involving diverse clients with varying data needs, such as building APIs, creating read models for specific user interfaces, and implementing event sourcing systems. It&amp;rsquo;s crucial for managing complexity and optimizing data transfer in distributed systems and microservice architectures.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;API Gateways/Backend for Frontends (BFF):&lt;/strong&gt; A BFF often uses projection to tailor API responses to the precise requirements of specific client applications (e.g., mobile app vs. web dashboard). This avoids sending unnecessary data over the network.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read Models in CQRS:&lt;/strong&gt; In Command Query Responsibility Segregation (CQRS), projection transforms write-side events into optimized read models for quick querying, offering a focused data view for each query.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Warehousing and ETL:&lt;/strong&gt; Transforming data from operational systems into denormalized, aggregated schemas optimized for analytical queries is a classic projection use case.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GraphQL:&lt;/strong&gt; GraphQL intrinsically uses projections, allowing the client to request only specific fields from the data graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GraphQL:&lt;/strong&gt; GraphQL is a query language for your API, and a runtime for fulfilling those queries with your existing data. Clients specify exactly which fields they need in a query, and the GraphQL server projects only those fields from the underlying data sources. For example, a client might request only the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; fields of a &lt;code&gt;User&lt;/code&gt; object, while the database contains additional fields like &lt;code&gt;passwordHash&lt;/code&gt; and &lt;code&gt;registrationDate&lt;/code&gt; which are never transmitted.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;React with Redux (Selectors):&lt;/strong&gt; In a React application using Redux, components often only need a small portion of the global application state. &lt;em&gt;Selectors&lt;/em&gt; act as projectors: they take the entire Redux state as input and extract and transform the specific data required by a component. Instead of passing the whole state to a component, a selector projects out a customized data view, enhancing performance and component decoupling. For instance, a user profile component might use a selector to project only the &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;profilePicture&lt;/code&gt;, and &lt;code&gt;bio&lt;/code&gt; from a larger &lt;code&gt;user&lt;/code&gt; object within the Redux store.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hibernate/JPA (DTOs and Projections):&lt;/strong&gt; JPA provides the ability to project data into Data Transfer Objects (DTOs). Rather than retrieving entire entities from the database, you can define a &amp;ldquo;projection&amp;rdquo; that maps only the required fields to a simple Java class (the DTO). This reduces database load and network traffic, similar to the benefit from GraphQL. For example, when displaying a list of product names and prices, you can project data into a &lt;code&gt;ProductSummary&lt;/code&gt; DTO instead of fetching the full &lt;code&gt;Product&lt;/code&gt; entity.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>