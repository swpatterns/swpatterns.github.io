<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Access Patterns on SWPatterns.com</title><link>https://www.swpatterns.com/pattern_types/data-access/</link><description>Recent content in Data Access Patterns on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 16:17:33 +0000</lastBuildDate><atom:link href="https://www.swpatterns.com/pattern_types/data-access/index.xml" rel="self" type="application/rss+xml"/><item><title>Table Data Gateway</title><link>https://www.swpatterns.com/pattern/table_data_gateway/</link><pubDate>Thu, 29 Feb 2024 16:17:33 +0000</pubDate><guid>https://www.swpatterns.com/pattern/table_data_gateway/</guid><description>
&lt;p&gt;The Table Data Gateway pattern provides an interface to a database table that encapsulates the table’s structure and ensures data consistency. It isolates the database-specific access logic from the rest of the application, making it easier to switch databases or modify the data access layer without impacting the core business logic. Essentially, it’s a class that represents the table, providing methods for all standard CRUD (Create, Read, Update, Delete) operations.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful when you want to abstract away the details of database interactions, providing a higher-level, object-oriented interface. It’s beneficial in scenarios where you need to support multiple databases or when your data model evolves frequently, as it centralizes the mapping between the object model and the relational database schema. This makes refactoring the data access logic significantly easier.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Legacy Systems:&lt;/strong&gt; Often used to modernize older applications with tight database coupling.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Portability:&lt;/strong&gt; Facilitates easier migration to different database systems by isolating database-specific code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Data Access:&lt;/strong&gt; Simplifies data access when dealing with intricate relationships and transformations within a single table.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reporting and Data Analysis:&lt;/strong&gt; Provides a clean interface for generating reports and performing data analysis operations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ruby on Rails ActiveRecord:&lt;/strong&gt; ActiveRecord in Ruby on Rails is a prime example. Each model class represents a database table, and methods like &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;destroy&lt;/code&gt; are implemented by the ActiveRecord layer, acting as a Table Data Gateway. The developer interacts with the model objects, and ActiveRecord handles the translation to SQL and database interaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Django ORM:&lt;/strong&gt; In Python’s Django web framework, the Object-Relational Mapper (ORM) provides a similar functionality. Each model corresponds to a database table, and the ORM’s methods (e.g., &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;create()&lt;/code&gt;, &lt;code&gt;save()&lt;/code&gt;, &lt;code&gt;delete()&lt;/code&gt;) encapsulate the database access logic, allowing developers to work with Python objects instead of raw SQL queries. This simplifies data interaction and ensures database consistency.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Query Object</title><link>https://www.swpatterns.com/pattern/query_object/</link><pubDate>Fri, 27 Oct 2023 16:31:00 +0000</pubDate><guid>https://www.swpatterns.com/pattern/query_object/</guid><description>
&lt;p&gt;The Query Object pattern encapsulates complex data retrieval logic into dedicated objects. Instead of scattering database or service queries throughout your application’s logic, you move them into these query objects. This promotes separation of concerns, making your domain models cleaner and more focused on their core responsibilities and enhancing testability.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful when dealing with complex reports, filtered lists, or any data request that doesn’t fit neatly into simple CRUD operations. It’s a common practice in applications that require flexible and customizable data access without tightly coupling those requirements to the entities themselves.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complex Reporting:&lt;/strong&gt; Generating reports that require data from multiple tables or applying intricate filtering and aggregation logic.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read-Only Data Access:&lt;/strong&gt; Scenarios where you need to retrieve information without modifying the underlying data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API Endpoints:&lt;/strong&gt; Implementing API endpoints that require specific data shaping or filtering before returning a response.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Decoupling Data Access:&lt;/strong&gt; Separating data retrieval logic from domain models to improve maintainability and testability.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ruby on Rails - Active Record Queries:&lt;/strong&gt; Rails&amp;rsquo; Active Record provides a query interface that can be seen as a form of Query Objects. You chain methods like &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt;, and &lt;code&gt;joins&lt;/code&gt; onto a model class to build up complex queries without directly writing SQL. For example: &lt;code&gt;User.where(active: true).order(created_at: :desc).limit(10)&lt;/code&gt; encapsulates a specific data retrieval request.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Symfony - Doctrine Repository:&lt;/strong&gt; In Symfony, Doctrine repositories are often used as Query Objects. They encapsulate the logic for fetching entities from the database. You can define custom methods within the repository class that execute specific queries, like retrieving users by role or finding the latest posts for a given category. Example: &lt;code&gt;$this-&amp;gt;getEntityManager()-&amp;gt;createQueryBuilder() -&amp;gt;select('u') -&amp;gt;from(User::class, 'u') -&amp;gt;where('u.role = :role') -&amp;gt;setParameter('role', 'ADMIN') -&amp;gt;getQuery() -&amp;gt;getResult();&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Identity Map</title><link>https://www.swpatterns.com/pattern/identity_map/</link><pubDate>Fri, 27 Oct 2023 10:30:00 +0000</pubDate><guid>https://www.swpatterns.com/pattern/identity_map/</guid><description>
&lt;p&gt;The Identity Map pattern ensures that each object has a unique representation in memory. It maintains a registry of objects already loaded from the database, and when an object is requested, the map checks if it already exists before retrieving it from the persistence store. This reduces memory consumption and improves performance by avoiding redundant database queries and object creation.&lt;/p&gt;
&lt;p&gt;This pattern is particularly useful in object-relational mapping (ORM) frameworks and complex data modeling scenarios. It&amp;rsquo;s common in applications dealing with a large number of interconnected entities where maintaining object identity is crucial for consistency and efficiency. By guaranteeing a single instance per database record, it simplifies object comparisons and prevents unexpected behavior due to duplicate data in memory.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Object-Relational Mapping (ORM):&lt;/strong&gt; Frameworks like Hibernate and Entity Framework heavily utilize Identity Maps to manage the persistence and retrieval of domain objects, ensuring consistency between in-memory state and the database.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caching:&lt;/strong&gt; As a form of object-level caching, it reduces database load and improves application response times.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Large Data Sets:&lt;/strong&gt; When dealing with a large graph of related objects, the Identity Map prevents memory explosion from creating multiple copies of the same object.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed Systems:&lt;/strong&gt; Can be adapted to work with distributed caches to provide consistent object identification across different application instances.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hibernate (Java):&lt;/strong&gt; Hibernate’s first-level cache acts as an Identity Map. When a user requests an entity, Hibernate first checks if it&amp;rsquo;s already present in the session&amp;rsquo;s Identity Map. If so, it retrieves the existing instance; otherwise, it loads it from the database and stores it in the map.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Doctrine ORM (PHP):&lt;/strong&gt; Doctrine&amp;rsquo;s Unit of Work and Identity Map work together to track changes to entities. The Identity Map establishes whether a given database identifier corresponds to an object that it&amp;rsquo;s already managing in memory. If it is, the existing object is used; if not, a new object will be created and added to the map.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Row Data Gateway</title><link>https://www.swpatterns.com/pattern/row_data_gateway/</link><pubDate>Fri, 27 Oct 2023 10:30:00 +0000</pubDate><guid>https://www.swpatterns.com/pattern/row_data_gateway/</guid><description>
&lt;p&gt;The Row Data Gateway pattern provides an interface to a database table. It encapsulates all the direct database access logic and exposes methods to perform operations on the table rows as objects. The gateway maps rows from one or more tables to objects, effectively presenting a higher-level, object-oriented view of the data.&lt;/p&gt;
&lt;p&gt;This pattern is beneficial when working with legacy databases or when a simple, direct mapping between database rows and objects is sufficient. It minimizes the amount of code needed to interact with the database and simplifies access for the client, though it can lead to tight coupling between the application and the database schema.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Row Data Gateway is commonly used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Legacy Systems:&lt;/strong&gt; Integrating with existing databases with limited or no ORM capabilities.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simple Data Models:&lt;/strong&gt; Applications with straightforward data relationships where the complexity of a full ORM is unnecessary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Performance-Critical Applications:&lt;/strong&gt; Provides fine-grained control over SQL queries, enabling optimization for specific database systems.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data migration and ETL processes:&lt;/strong&gt; When reading and writing data efficiently to and from various sources.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ruby on Rails (ActiveRecord without Associations):&lt;/strong&gt; Before the widespread adoption of complex ActiveRecord associations, simple ActiveRecord models acted as Row Data Gateways for single tables. Each record instance directly represented a row in the database, and methods like &lt;code&gt;.find()&lt;/code&gt;, &lt;code&gt;.create()&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, and &lt;code&gt;.destroy()&lt;/code&gt; translated to specific SQL queries on the corresponding table.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JDBC in Java:&lt;/strong&gt; Using JDBC directly to interact with a database, you essentially implement a Row Data Gateway manually. Code directly executes SQL queries and maps the &lt;code&gt;ResultSet&lt;/code&gt; rows to Java objects. Libraries like Spring JDBC provide a layer of abstraction but still rely on the core principles of this pattern by handling database connections and result set mapping.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java
public class CustomerGateway {
private JdbcTemplate jdbcTemplate;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public CustomerGateway(JdbcTemplate jdbcTemplate) {
this.jdbcTemplate = jdbcTemplate;
}
public Customer getCustomer(int id) {
String sql = &amp;quot;SELECT * FROM Customers WHERE CustomerID = ?&amp;quot;;
return jdbcTemplate.queryForObject(sql, new Object[]{id}, new CustomerRowMapper());
}
// other methods to insert/update/delete customers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;</description></item></channel></rss>