<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architectural Patterns on SWPatterns.com</title><link>https://swpatterns.com/pattern_types/architecture/</link><description>Recent content in Architectural Patterns on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 10:30:00 +0000</lastBuildDate><atom:link href="https://swpatterns.com/pattern_types/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Sharding</title><link>https://swpatterns.com/pattern/sharding/</link><pubDate>Thu, 29 Feb 2024 10:30:00 +0000</pubDate><guid>https://swpatterns.com/pattern/sharding/</guid><description>
&lt;p&gt;Sharding is a database architecture pattern used to horizontally partition a dataset across multiple machines (shards). This is typically done when a single database instance can no longer handle the growing volume of data or the increasing number of read/write operations. Each shard contains a subset of the total data and operates as an independent database. A sharding key is used to determine which shard a particular piece of data belongs to.&lt;/p&gt;
&lt;p&gt;This pattern aims to improve performance, scalability, and availability of database systems. By distributing the load across multiple servers, sharding reduces the single point of contention and allows for parallel processing. It also enables easier scaling by adding more shards as needed. However, sharding introduces complexity in data management, querying, and transaction handling.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Sharding is commonly used in the following scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Large Datasets:&lt;/strong&gt; When the data volume exceeds the capacity of a single database server.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;High Traffic:&lt;/strong&gt; When the number of concurrent users or requests overwhelms a single database instance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geographical Distribution:&lt;/strong&gt; When data needs to be stored closer to users in different regions to reduce latency.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Performance Bottlenecks:&lt;/strong&gt; When a specific database operation (e.g., reporting, analytics) is causing performance issues.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices Architectures:&lt;/strong&gt; Each microservice can have its own sharded database.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MongoDB:&lt;/strong&gt; MongoDB offers built-in sharding capabilities. It uses a shard key to distribute data across multiple shards, and a config server to maintain metadata about the sharded cluster. This allows MongoDB to scale horizontally to handle massive datasets and high throughput.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CockroachDB:&lt;/strong&gt; CockroachDB is a distributed SQL database designed for scalability and resilience. It automatically shards data across multiple nodes, providing high availability and performance. Data is partitioned based on a range of keys, and the system handles data rebalancing and replication.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis Cluster:&lt;/strong&gt; Redis Cluster provides a way to automatically shard Redis datasets. The cluster distributes data across multiple Redis nodes, and uses a hash slot to determine which node holds a particular key. This allows Redis to scale beyond the memory limits of a single machine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apache Cassandra:&lt;/strong&gt; Cassandra is a NoSQL database that uses a distributed architecture with sharding as a core principle. Data is partitioned across nodes using a consistent hashing algorithm, ensuring even distribution and fault tolerance.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Gateway Offloading</title><link>https://swpatterns.com/pattern/gateway_offloading/</link><pubDate>Fri, 27 Oct 2023 10:00:00 +0000</pubDate><guid>https://swpatterns.com/pattern/gateway_offloading/</guid><description>
&lt;p&gt;The Gateway Offloading pattern addresses scalability and performance issues in systems with a central gateway component. It involves distributing the load from the gateway to other services or infrastructure components – such as Content Delivery Networks (CDNs), alternative backend services, or dedicated processing units – before it reaches the core backend systems. This is particularly useful when the gateway becomes a bottleneck due to high request rates, complex processing, or limited resources.&lt;/p&gt;
&lt;p&gt;This pattern prevents gateway overload by intelligently routing or handling certain requests externally. This can involve caching static content at the edge, directing requests to specialized backend instances, or asynchronously processing non-critical tasks. Effectively implemented gateway offloading improves response times, increases system availability, and reduces infrastructure costs by optimizing resource utilization.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Handling Static Content:&lt;/strong&gt; Offloading static assets (images, CSS, JavaScript) to a CDN dramatically reduces the load on the gateway and backend servers, improving page load times for users globally.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API Rate Limiting &amp;amp; Authentication:&lt;/strong&gt; Placing rate limiting and authentication logic in a separate service, and offloading those requests &lt;em&gt;before&lt;/em&gt; they hit the backend, protects core backend services from abuse.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microservices Architectures:&lt;/strong&gt; In a microservices environment, a gateway can offload traffic to different microservices based on request type or content, improving microservice independence and scalability. Also, can provision resources based on predicted or measured load.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peak Traffic Management:&lt;/strong&gt; Duplicating backend functionality or utilizing read-replicas and switching traffic during peak loads, offloaded by the gateway, ensures high availability.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Data Transformations:&lt;/strong&gt; Offloading CPU-intensive data transformations, such as image resizing or video transcoding, to dedicated processing units prevents the gateway from becoming a bottleneck.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cloudflare:&lt;/strong&gt; Cloudflare operates as a reverse proxy and provides extensive gateway offloading features. It caches static content globally, handles DDoS protection, offers web application firewall (WAF) capabilities, and can route traffic based on various criteria, all relieving the origin server&amp;rsquo;s load. Their &amp;ldquo;Workers&amp;rdquo; feature allows running code at the edge.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amazon API Gateway with Lambda Integrations:&lt;/strong&gt; Amazon API Gateway can offload functionalities like authentication, authorization, request validation, and rate limiting. Additionally, it can integrate with AWS Lambda functions to perform serverless processing, distributing the computational burden away from the core API backend.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netflix:&lt;/strong&gt; Netflix uses various CDNs (like Akamai and Open Connect) to deliver streaming content to users worldwide. This offloads the significant bandwidth requirements from their origin servers and improves the viewing experience. Their Zuul gateway offloads authentication and routing.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kong Gateway:&lt;/strong&gt; Kong Gateway is an open-source API gateway that provides plugins for offloading functionalities such as authentication, authorization, rate limiting, and request transformation. It can integrate with various upstream services and backends.&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>